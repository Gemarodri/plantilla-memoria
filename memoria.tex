%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage{multirow} % para las tablas
\usepackage{pdfpages}

\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
MASTER EN INGENIERIA DE TELECOMUNICACIONES

\vspace{0.4cm}

\large
Curso Académico 2015/2016

\vspace{0.8cm}

Trabajo Fin de Máster

\vspace{2.5cm}

\LARGE
%BUG SEEDING, IDENTIFICATION OF BUG AND THE IMPORTANCE OF COMMIT ANTECESOR
BUG SEEDING, IDENTIFICACION DEL ERROR Y LA IMPORTANCIA DEL COMMIT ANTECESOR
\vspace{4cm}

\large
Autor : Gema Rodríguez Pérez \\
Tutor : Dr. Jesús María Gonzalez Barahona
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Proyecto Fin de Carrera}

\vspace{1cm}
\large
BUG SEEDING, IDENTIFICACION DEL ERROR Y LA IMPORTANCIA DEL COMMIT ANTECESOR

\vspace{1cm}
\large
\textbf{Autor :} Gema Rodríguez Pérez \\
\textbf{Tutor :} Dr. Jesús María Gonzalez Barahona

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 2016, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 2016
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi abuelo, Ismael.}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

En primer lugar, agradecer a mi familia todo el apoyo recibido, así como toda la confianza depositada en mi desde que decidí adentrarme en el mundo de las Telecomunicaciones.  Quiero dejar constancia de lo agradecida que me siento con mis padres, ellos son los que me han sufrido en las épocas de estrés, y a pesar de ello siempre me han regalado palabras de ánimo y aún hoy, me siguen brindando grandes consejos. <Gracias Padres!. También quiero nombrar el agradecimiento que siento hacia mis abuelos, ellos han celebrado tanto como yo cada uno de mis aprobados, y han sufrido conmigo en los suspensos.

Me gustaría agradecer también a todas las personas que comparten mi día a día de un modo u otro, aportándome buenos momentos y haciéndome feliz, gracias a ellos el estudiar, trabajar ó incluso el madrugar se hace mucho mejor.

Llegados a este punto, y mirando todo lo que las telecomunicaciones me ha ofrecido, si volviese a elegir una carrera, no dudo que sería la misma. En ella he encontrado grandes amigos, experiencias inolvidables, y como no, la importancia del esfuerzo constante. Además, he tenido la posibilidad de conocer a esos grandes profesores, profesores de vocación que hacen que este mundo del que ahora formo parte sea algo fascinante.

Por último, me gustaría agradecer a mi tutor, Jesús, toda la ayuda recibida durante el proyecto y la  confianza que ha depositado en mi para que logre llevarlo a cabo.

\textit{<<El crecimiento es un proceso de prueba y error: es una experimentación. Los experimentos fallidos forman parte del proceso en igual medida que el experimento que funciona bien>> - Benjamin Franklin.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Este proyecto se inscribe en el marco de la ingeniería del software, concretamente en el área dedicada a encontrar cómo y cuándo se introdujo un error no intencionado en el código fuente, en inglés, conocido como bug-seeding. Existen herramientas que permiten detectar si el código alberga errores ó si es propenso a ello, analizando semánticamente y sintácticamente su estructura. A pesar de ello, el software se ve sometido a cambios que provocan que deje de funcionar, ocasionados por errores indetectables en las pruebas de test. Y es ahí dónde se contextualiza nuestro proyecto, aportando información sobre de qué manera y en qué momento el error fue introducido al código.

Partiendo de una teoría actualmente asumida por los desarrolladores que trabajan en este área, hemos llevado a cabo el estudio de investigación presentado en esta memoria. Dicho estudio aporta datos empíricos que muestran la validez del teorema aplicada al estudio de un proyecto en concreto. Nuestra intención no es otra que, ayudar a entender mejor el proceso involucrado en el bug-seeding, desde que aparece un error hasta que se soluciona, identificando el momento en el que dicho error fue introducido, poniendo atención a la importancia que ejerce el cambio previo en la insercción del error.

Además, en la memoria se presenta una herramienta desarrollada durante la investigación, cuyo objetivo es mecanizar la fase de análisis lo máximo posible, ayudándonos a ahorrar tiempo en la extracción de datos y mostrándo de manera atractiva la información que ayuda a los desarrolladores a tomar sus decisiones. Cabe mencionar, que la herramienta se encuentra validada por nuestro análisis, y ha sido diseñada para trabajar con el proyecto que estábamos investigando. Por tanto, actualmente no da soporte para analizar otros proyectos.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

This project is focused on a specific area of software engineering, the study of how and when bug was inserted into source code, also known as bug seeding. We can find many tools that help us to prevent errors in the code analyzing its sintactical and semantical structure. But, sometimes the errors are undetectables and pass the tests, causing the system to fail. This project contribute to understand the procedure implicated in bug seeding, providing information about how and when the bug was introduced into the source code, also who previous change caused the bug. 

We have conducted an observational study that englobes many tickets extracted from a free and open-source cloud computing software platform. The experiment was focused as a first approach to prove that the currently premise established does not hold for all cases. Understanding the importance of the previous commit in the bug-seeding.

Furthermore, in this project we showed a tool developed, which automates one part of the methodology used to distinguish between bug reports and other issues. The tool minimizes the time required to analyzing the data extracted, and shows us intuitively all data in the same interface.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números
%[Hablar de las motivaciones que nos han llevado al estudio, el proyecto fin de master lo vamos a enfocar como la realización de una herramienta que nos ayudó en un estudio que estamos realizando y que ademas es validada con el propio estudio]
%[En la intro ademas de hablar sobre las motivaciones tenemos que hablar sobre la herramienta html5, con sus partes de servidor y usuario en referenciando las secciones en las cuales describimos la herramienta ]

El software libre y de código abierto, \textit{FLOSS}, nos ofrece la gran ventaja de mejorar continuamente su diseño; los desarrolladores estudian, modifican y mejoran el software gracias a la disponibilidad del código fuente. La evolución de la ingeniería del software libre, ha favorecido la aparición de repositorios de versiones, donde se puede observar la evolución a la que se somete el código, permitiendo a los desarrolladores investigar como se lleva a cabo todo el proceso de desarrollo. 

El desarrollo en sistemas \textit{FLOSS} puede llegar a ser algo complejo ya que en este tipo de sistemas se permite a todo el mundo contribuir, desarrolladores noveles y expertos cooperan para mejorar el software. Por tanto, es imposible tratar de prevenir las necesidades de todos ellos, así como los errores que aparecerán. Cientos de desarrolladores tendrán que permanecer atentos en las actividades que precisan mantenimiento; añadiendo nuevas características, mejorando las existentes ó corrigiendo errores. Por este último motivo, los investigadores encontraron la necesidad de entender que cambios provocaron un fallo en el sistema para poder tratar de prevenirlos en el futuro. Así, surgieron los conceptos de bug-fixing, lo que en español se entiende como el proceso encargado de corregir un error, ó bug-introducing/bug-seeding que se traduce como el momento en el que se insertó un error en el código fuente.
  
En los últimos años, se ha puesto mucho esfuerzo en entender el bug-seeding, investigando a partir de un error arreglado, quien lo causó. Además, una vez encontrado que cambio previo causó el error, se pueden sacar métricas de él que nos ayuden en este entendimiento. Así pues, se han desarrollado multitud de algoritmos y herramientas que ayudan a prevenir la insercción de errores en el códigio fuente. Estas herramientas y estudios son muy útiles para evitar insertar errores en el software, pero todas ellas asimilan una misma idea que parece razonable pero que no ha sido probada empíricamente.

Nuestra aportación con este trabajo de investigación, se centra en aportar datos empíricos sobre la asunción que todos los estudios previos presentan. Nos centraremos en entender cómo y cuándo un error fue introducido en el código a través de un cambio, y analizando ese cambio podremos saber si causó el error o no. 

Esta memoria se estructura de la siguiente manera; en la sección 1 se presenta una breve introducción sobre el tema a tratar en esta memoria, presentando la carencia encontrada actualmente en la literatura y la solución propuesta en las subsecciones 1.1 y 1.2. La sección 2, trata de introducir al lector en el estado de la técnica actual, subsección 2.1, y contextualuzar el proyecto en las subsecciones 2.2 y 2.3. En la sección 3, se detallan las tecnologías usadas en el desarrollo de nuestra herramienta. En la sección 4 se detalla el estudio que hemos llevado a cabo. Dicho estudio consta de dos fases, explicadas en las secciones \ref{sec:fase1} y \ref{sec:fase2}, durante las que se extraen y se analizan datos, obteniendo una clasificación final en cada una de ellas. En la realización de estas fases, nos dimos cuenta que ciertas partes de nuestra metodología se podían mecanizar, por ese motivo y para ahorrar tiempo, se desarrolló la herramienta descrita en el capitulo \ref{sec:DescHerramienta}. Los resultados obtenidos tras finalizar el estudio se muestran en el capitulo \ref{sec:resultados}. Las conclusiones aparecen en el capitulo \ref{chap:conclusiones}, donde la primera sección \ref{sec:consecucion-objetivos}, habla sobre los objetivos descritos en la sección \ref{sec:objetivos} que han sido cumplidos. En la sección \ref{sec:trabajos_futuros} aparecen algunas de las líneas de trabajo futuro. Además, para finalizar, en el anexo \ref{app:articlel} se adjunta un documento que detalla todo el trabajo de investigación realizado.

En \url{http://gemarodri.github.io/Presentacion/} podemos encontrar una web que reúne todos los recursos disponibles en el TFM como son, esta memoria, la herramienta desarrollada y su código fuente. Además, hemos añadido una demo en la que se presenta el funcionamiento de la herramienta. 

\section{El problema}
\label{sec:ElProblema}

Como se ha mencionado anteriormente, la falta de evidencia empírica que pruebe la actual idea concebida en la literatura actual sobre el bug-seeding es el problema del que parte esta memoria. Esta idea asume que el cambio anterior en las líneas que han sido arregladas posteriormente causó la aparicion del error en el código fuente. Esta idea tiene mucho sentido y señala al commit\footnote{acción de comprometer, cambio que indica que cierto conjunto de operaciones realizadas sobre una base de datos, ha culminado de efectuarse correctamente. } anterior como el responsable de causar el error pero sin embargo no ha habido ningún estudio que demuestre empíricamente que es cierta, y creemos que hay otros cambios y otras circunstancias en las que el commit previo no causó ningún error. 

Fue Zimmermann en uno de sus artículos \cite{sliwerski2005changes}, quien apuntó que el cambio anterior es el causante del posterior arreglo (\textit{'This earlier change is the one that caused the later fixed'}). Otros autores como James Whitehead, ni siquiera indican en sus artículos que el commit anterior es el responsable, si no que ya parten de esa idea, lo tienen asumido. Al igual que sucede con J. Whitehead, esta idea preconcebida se encuentra tan generalizada que la mayoría de estudios de investigación relacionados con el bug-seeding parten de ella. Existen artículos recientes como \cite{fejzer2015supporting}, donde se presentan herramientas que detectan automáticamente los cambios que pueden ser futuros errores, pero estas herramientas también parten de la misma idea (\textit{'We assume that a change/commit is buggy if its modifications has been later altered by a bug-fix commit'}). Hasta el momento no hemos descubierto ningún estudio ó investigación empírica que trate de contribuir a este pensamiento generalizado aportando datos ó porcentajes que muestren en cuantas ocasiones la literatura actual se cumple, y en cuantas ocasiones esta idea no es acorde con los datos.

\section{La solución}
\label{sec:solucion}
Debido a esta carencia en la literatura actual, decidimos desarrollar un estudio de investigación, enfocado en descubrir y analizar el momento en el que un cambio en el código fuente insertó un error, y a partir de ese momento, poder identificar al/los causantes de dicho error. Consiguiendo finalmente una evidencia empírica sobre el número de errores introducidos por el commit anterior, y aquellos errores introducidos en los que el commit anterior no causó el posterior arreglo.

Para realizar dicho estudio, nos centramos en analizar el proyecto OpenStack, concretamente uno de sus componentes, Cinder. OpenStack se ayuda de herramientas como Launchpad, Gerrit y Git, para funcionar. Launchpad es un sistema de seguimientos de errores donde los desarrolladores dejan constancia de las especificaciones que requiere el sistema, usando lo que se conoce como \textit{blueprint}. A través de los \textit{blueprint} se describe una idea, ya sea una característica o un proceso, que llevará asignados metadatos (\textit{identificador, proyecto al que pertenece ó importancia} ) que permiten que sea rastreado. Nosotros estamos interesados en aquellos \textit{blueprint} que se han etiquetado en el sistema como errores. Una vez que dichos errores han sido  descritos en Launchpad, y mediante su identificador único, la evolución del error se puede seguir en Gerrit, que no es más que un sistema de revisión de código donde se discute los posibles arreglos para que el software vuelva a funcionar. Cuando los arreglos propuestos son aceptados, Git se encarga de introducirlos al código fuente a través un commit, arreglando así el error. 

Gracias a esta conexión en las herramientas, podemos rastrear un error y encontrar el momento en el que fue introducido, puesto que tenemos a nuestra disposición todo el historial de cambios que se han realizado en el software. Este proceso no es único de Openstack, si no que es relativamente típico en otros proyectos que usan las mismas herramientas, como Mahara\footnote{\url{https://mahara.org}}.

Una vez que sabemos como rastrear un error obteniendo el momento en el que se introdujo, podemos averiguar quien causó el error, y si el commit previo fue quien provocó dicho fallo. Todo este proceso se realizó manualmente hasta obtener una metodología adecuada, muchos de los pasos descritos en la metodología se podían automatizar ya que se repetían constantemente y es por eso que decidimos diseñar la aplicación web, para facilitarnos el trabajo reduciendo aproximadamente de 5 a 10 minutos el tiempo de análisis de cada ticket.

\section{Los objetivos}
\label{sec:objetivos}

Los objetivos propuestos abarcan dos ámbitos claramente diferenciados. Por un lado, el estudio de investigación, y por otro lado, la heramienta desarrollada.  

La obtención de datos fiables a través del análisis del proyecto, ayudará a generar diversas gráficas, aportando de forma visual los datos obtenidos. La tendencia que pueden mostrar las gráficas y nuestras expectativas al respecto, marcarán un punto de inflexión en la investigación, viéndonos en la necesidad de pararnos a pensar y debatir sobre el futuro de la investigación. 

Por tanto, los objetivos a cumplir en el proyecto de investigación son:
\begin{itemize}
    \item Objetivo 1: Entender el proceso requerido para rastrear un error. Es decir, partiendo del error, saber cómo y dónde buscamos para encontrar el momento en el que se introdujo el error.
    \item Objetivo 2: Escribir una metodología adecuada para identificar al responsable, de manera que que nuestra investigación sea reproducible.    
    \item Objetivo 3: Obtener porcentajes fiables que nos permitan conocer las veces que la teoría actual se cumple en nuestro caso de estudio.     
    \item Objetivo 4: Obtener porcentajes fiables que nos permitan conocer las veces que la teoría actual no se cumple en nuestro caso de estudio. 
    \item Objetivo 5: Aportar gráficas en las que se relacionen los datos extraídos con la teoría actual.
\end{itemize}

Por otro lado, y tras ver que nuestra metodología no era solamente reproducible si no que podía ser automatizada, planteamos una serie de objetivos a cumplir, que se encuentran listados a continuación. Seguiremos con la numeración anterior para luego poder referenciarlos en las conclusiones.
\begin{itemize}
    \item Objetivo 6: La metodología consta de dos fases, por tanto trataremos de automatizar lo máximo posible ambas fases.
    \item Objetivo 7: La herramienta es una ayuda en nuestra investigación, por tanto la información que se presentar en ella debe ser lo más atractiva posible, y de la misma manera ser intuitiva para el usuario.
    \item Objetivo 8: Para que el proyecto llegue a tener gran envergadura, será necesario generalizar la herramienta lo máximo posible.
      \item Objetivo 9: Uno de los objetivos principales para desarrollar la herramienta, es que en realidad nos ahorre tiempo en el análisis, por tanto deberemos comprobar que esto se cumple.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL LA TƒCNICA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\chapter{Estado del arte y contexto}
Este capítulo se encuentra dividido en tres secciones. La primera sección está dedicada a explicar las motivaciones que nos han llevado a realizar el estudio de investigación. Donde partimos de un gran proyecto como es OpenStack para realizar el análisis de una población de tickets pertenecientes a uno de sus componentes, concretamente Cinder. Por tanto, la segunda sección se centra en explicar el proyecto OpenStack, profundizando en entender de manera superficial qué es y cómo funciona, pero centrándose más en la explicación de Cinder, ya que este proyecto es nuestro caso de estudio.

Como ya se mencionó en la introducción, OpenStack usa Launchpad como herramienta de mejora continua, notificando la posibilidad de nuevas características, errores encontrados y mejoras en el funcionamiento. Gerrit proporciona a OpenStack un repositorio de revisión de código, donde todos los cambios propuestos se debaten y se analizan para que no interfieran en el buen funcionamiento del sistema. Por último, Git es la herramienta encargada de añadir los cambios aceptados al código fuente. Estas tres herramientas se explican en mayor detalle en la tercera sección de este capitulo.

\section{Precedentes}
\label{sec:precedentes}

La literatura actual acerca de la inserción de errores en el código fuente, asienta sus bases en la idea preconcebida de que el error ha sido causado por el commit inmediatamente anterior, puesto que fue el último cambio que modificó las líneas que se vieron involucradas en el posterior arreglo. A partir de esta asunción, se desarrollan multitud de estudios y experimentos relacionados con el bug-seeding, bug-fixing, ó cualquier tema que involucre el concepto de encontrar al responsable de introducir el error en el código. 

La idea principal en \cite{pan2009toward} es la búsqueda de patrones de errores resueltos en el código fuente, analizando el código de los ficheros en las diferentes revisiones que nos proporciona un sistema SCM, centrandose en la semántica del código fuente.

Estudios como \cite{kim2008classifying}, presentan una técnica usada para la predicción de errores latentes en los códigos, separa aquellos cambios en los que el código indica que son errores de aquellos que no son errores. Para conseguirlo, usan la ayuda del machine learning,  identificando de este modo si un nuevo cambio en el código es más \textit{buggy} ó mas \textit{clean}, es decir, es más propenso a errores o no. 

Mientras que en \cite{izquierdo2011developers} se investiga que porcentaje de desarrolladores arreglan sus propios bugs, asumiendo que los commits inmediatamente anteriores son los causantes del error. Del mismo modo, en \cite{sliwerski2005changes}, tratan al commit previo como el causante de introducir el error al código.
 
El afán por prevenir los errores en el código ha dado estudios como \cite{zimmermann2005mining} , donde se aplica la minería de datos, \textit{Data Mining}, a las versiones de un repositorio. Con el objetivo de guiar a los programadores en los cambios realizados, sugiriendo lo que otros desarrolladores han hecho anteriormente. De esta manera consiguen prevenir los errores debidos a cambios incompletos.

Hasta el momento, no hemos encontrado ningún estudio que intente conocer si el commit anterior es el verdadero causante del error o no, si no que, todos los estudios analizados en esta memoria señalan como causante al commit previo. Por lo tanto, nuestro estudio se focaliza en ayudar a comprender mejor la causa de fallo en el código fuente, aportando a la literatura actual un posible nuevo enfoque. Nuestro objetivo no es otro que comprobar empíricamente en cuantos casos la literatura actual acerca del causante de un error se cumple y en cuantos casos la literatura podría no ser del todo correcta. Y para ello, nos centramos en el análisis de el/los commit/s inmediatamente anteriores al error introducido. 

En el análisis, se tendrán en cuenta ciertas características de los commits que nos ayudan a tomar decisiones. Esta misma idea se encuentra en \cite{sliwerski2005changes}, donde al tener en cuenta ciertas propiedades sobre los cambios que conducían a posteriores arreglos, como por ejemplo el día de realización de los cambios, se encontró que los viernes se introducen más fallos en el código.

En las referencias anteriores, así como en nuestro estudio de investigación, el uso de la herramienta \textit{Diff} es de gran utilizad. Puesto que lo usamos para identificar cambios entre diferentes versiones de un mismo fichero. Es más, los autores del algoritmo SZZ hacen uso de \textit{Diff}. Dicho algoritmo, descrito en \cite{sliwerski2005changes}, tiene como propósito determinar el origen de un error identificando el commit que lo arregló, enlazando el número del ticket en el que se reporta el fallo con el commit que arregla ese error. Para ello, asumen que las líneas que han sido eliminadas o modificadas en el commit que arregló el error son las causantes de dicho error. \textit{Diff} presenta un pequeño problema que envuelve a las líneas que no se modifican, si no que se cambian de lugar, y esto puede provocar un error en las características extraídas de los commits. 

En \cite{zimmermann2006mining} presentan un estudio a nivel de línea, identificando las líneas que cambian y cómo lo hacen a lo largo de las versiones. Los autores eliminan el concepto de número de línea y lo sustituyen por nodos en un grafo, un nodo por cada revisión, obteniendo así una mayor información de la vida de las líneas, ya que actualmente todos los sistemas de control de versiones nos devuelven la última modificación realizada, perdiendo información que podría ser útil.

Al igual que nosotros, \cite{kim2008classifying} y \cite{hindle2008large} entienden que un cambio se puede clasificar dentro de una o varias categorías dependiendo de la intención de dichos commits. 

\section{Proyecto OpenStack}
\label{sec:openstack}

OpenStack es el nombre asociado a un proyecto software, integramente  \textit{Open-Source} ó código abierto, cuyo propósito es combinar una serie de proyectos para construir y manejar plataformas de computación en la nube, para nubes tanto públicas como privadas. Principalmente los usuarios lo desarrollan para conseguir una infraestructura como servicio, comúnmente conocido como IaaS (Infrastructure as a Service), permitiéndole dirigir y gestionar distintos aspectos. Se distribuye bajo la licencia de Apache y es software libre y distribuido.

Un aspecto que hace interesante a OpenStack es su capacidad de extensibilidad a través de sencillas APIs, este factor ha hecho posible que muchos proveedores de servicios usen OpenStack como elemento clave de su infraestructura. OpenStack se está convirtiendo en una referencia de implementación en la construcción de nubes privadas y públicas. Se encuentra respaldado por grandes empresas como  \textit{Cisco, Paypal, Webex, Ebay, NASA, Rackspace, Dell, HP, Comcast, Seagate, Intel, AT\&T y NetApp}.

OpenStack ha conseguido convertirse en el mayor proyecto libre de IaaS, su éxito puede ser debido al poderoso framework que han creado, haciendo mas cómodo la infraestructura IaaS.  

OpenStack se compone de proyectos claramente identificados como parte del núcleo ó  \textit{core}, que se encuentran relacionados entre sí y dependen de la versión utilizanda. A continuación se detallan los componentes incluidos en la versión Juno (16 Octubre del 2014), ya que en nuestro estudio la vesión que estaba siendo usada era esta:

\begin{itemize}
    \item Compute,  \textit{Nova}: Proporciona máquinas virtuales bajo demanda, también permite gestionar volúmenes de disco a través de uno de sus servicios. Es el controlador de la estructura básica del  \textit{Cloud}. Se encarga de iniciar las instancias de los usuarios y grupos.
    \item Object Store,  \textit{Swift}: Proporciona almacenamiento de objetos. Nos permite almacenar y recuperar ficheros, realizar copias de seguridad, almacenamiento de audio/vídeo en streamings, etc. Pero no podemos montar sistemas de ficheros basados en  \textit{NFS}. En Swift se incluyen un servidor proxy, un servidor de cuentas de usuario y ciertos procesos ejecutados periódicamente para limpiar datos. 
    \item Block Storage,  \textit{Cinder}: Proporciona almacenamiento de bloques que se usan en las instancias de OpenStack. Complementa al almacenamiento que nos proporciona Swift.
    \item Networking,  \textit{Neutron}: Proporciona conectividad de red como servicio, de tal forma que permite alta flexibilidad a los usuarios finales para interconectar y crear sus propias redes.
    \item Dashboard,  \textit{Horizon}: Proporciona una aplicación web para el manejo de instancias y volúmenes. Permite la comunicación entre las distintas APIs de OpenStack de forma sencilla. No proporciona toda la funcionalidad que podríamos conseguir usando un interprete de comandos, pero todo lo que hace lo hace correcto.
    \item Identity,  \textit{Keystone}: Servicio usado para la autentificación entre el resto de componentes. Utiliza un sistema de autentificación basado en tokens.
    \item  Image Service,  \textit{Glance}: Proporciona la búsqueda y recuperación de máquinas virtuales.
    \item Telemetry Service,  \textit{Ceilometer} : Permite recoger de forma fiable las mediciones de la utilización de recursos físicos y virtuales que comprenden las Clouds que se encuentran desplegadas. Se analizan los datos y se desencadena acciones cuando ciertos criterios definidos se cumplen. 
    \item Orchestration,  \textit{Heat}: Proporciona ayuda para manejar la infraestructura que se necesita para un servicio de Cloud, para ello realiza peticiones REST y Query a la API.
    \item Database Service,  \textit{Trove}: Proporciona una base de datos que funciona como un servio de aprovisionamiento de bases de stand relacionales y no relacionales.
    \item Data Processing,  \textit{Sahara}: Proporciona un medio sencillo para la provisión de un clúster de aplicaciones de datos intensivos en la parte superior de OpenStack.
\end{itemize}

La gran comunidad de OpenStack es la encargada oficial de mantener a punto estos sistemas. Cada uno de ellos tiene su propia API para alcanzar una mejor integración. Además, se encuentra bien documentada, soportada por numerosos fabricantes y distribuidores de software. 

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{img/serviceOpenStack}
    \caption{Relaciones entre los servicios de OpenStack}
    \label{figura:serviceOpenstack}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{img/JunoStatics}
    \caption{Estadisticas de la versión Juno}
    \label{figura:JunoStatics}
\end{figure}

En la imagen~\ref{figura:serviceOpenstack} extraída de la siguiente url\footnote{ \url{https://wiki.openstack.org/wiki/Documentation/HowTo#Introduction} }, se presenta una visión muy simplificada acerca de la arquitectura de OpenStack, la imagen no muestra la interacción con los consumidores del \textit{Cloud}.

Como podemos comprobar, OpenStack es un gran proyecto, complejo y que se encuentra en continuo desarrollo. Los datos que lo avalan se pueden ver en la figura ~\ref{figura:JunoStatics}, extraída usando la herramienta Bicho, disponible en  la url \footnote{\url{http://activity.openstack.org/dash/browser}}. En la imágen podemos ver una captura de la web donde encontramos gráficas que muestran las estadísticas relacionadas con la 'release' de Juno. Podemos observar como el elevado número de tickets, de desarrolladores y de commits hacen factible la elección de este gran proyecto como caso de estudio.  

Concretamente, nos centraremos en analizar uno de los componentes de OpenStack, Cinder. Nos pareció más adecuado empezar por analizar uno de sus componentes para, quizás en un futuro, acabar analizando el proyecto entero.

\subsubsection{Cinder} 

 Originariamente, el código de Cinder se albergaba en Nova bajo la etiqueta de \textit{'nova-volume'}. A partir de la versión Folsom (27 de septiembre de 2012), se creó el componente Cinder. Este componente de OpenStack es el encargado de proporcionar dispositivos de almacenamiento para instancias de OpenStack. Gestiona el almacenamiento de bloques, manipulando volúmenes y copias instantáneas de ellos conocidas como \textit{'snapshots'}. El Dashboard que proporciona OpenStack permite a los usuarios gestionar sus propias necesidades de almacenamiento. 

El almacenamiento de bloques es aconsejable usarlo cuando el rendimiento es delicado, por ejemplo en bases de datos, sistemas de archivo expandibles, etc. Cinder tiene su propia Base de Datos en la que se encuentra el estado de cada volúmen.

Cinder se compone de:
\begin{itemize}
    \item Cinder API:  Acepta los pedidos y los enruta para que sean procesados.
    \item Cinder Volume: Lee y escribe sobre la base de datos. Puede interactuar con otros procesos a través de la cola de mensajes ó directamente sobre el almacenamiento.
    \item Cinder Scheduler: Selecciona el nodo donde se almacenarán por bloques los volúmenes creados.
\end{itemize}

Decidimos analizar el repositorio de Cinder ya que posee gran dinamismo, los errores se reportan en el repositorio que está habilitado para ello en Launchpad y los desarrolladores comienzan su labor para intentar solucionarlos. 

En la figura ~\ref{figura:cinderStaticsAll} extraída de la url\footnote{\url{http://activity.openstack.org/dash/browser/repository.html?repository=https\%3A__bugs.launchpad.net_cinder&ds=its}} se muestra diferentes estadísticas sobre la historia de Cinder.  
\begin{figure}
    \centering
    \includegraphics[scale=0.35]{img/cinderStaticsAll}
    \caption{Estadísticas de Cinder}
    \label{figura:cinderStaticsAll}
\end{figure}

\section{Herramientas utilizadas}
\label{sec:herramientas}

Esta sección es la encargada de especificar de que manera OpenStack hace uso de herramientas como son Launchpad, Gerrit y Git. Antes de entrar en detalle en la explicación de cada una de las herramientas, empezaremos por una primera aproximación, relacionando OpenStack con Launchpad, Gerrit y Git.

La comunidad de desarrolladores de OpenStack utiliza Launchpad como herramienta para notificar mejoras en el programa, errores en el código, la necesidad de nuevas características, etc. Estos posts ó notificaciones se denotarán como tickets a lo largo de esta memoria. Gerrit proporciona un seguimiento personalizado para cada ticket, esta herramienta nos permite poder visualizar los diferentes estados por los que pasan los ficheros involucrados en el ticket hasta obtener la solución correcta. Por último, Git es la herramienta que proporciona un repositorio de almacenamiento de código fuente a OpenStack y es la encargada de añadir los cambios al código.

El proceso que sigue un ticket desde que se abre hasta que se cierra, se encuentra descrito a continuación:
\begin{enumerate}
\item Un ticket es creado atendiendo a la necesidad de cierta persona/desarrollador que cree necesario notificar una mejora, un bug, una nueva funcionalidad o algo con cierta relevancia. Ver imágen ~\ref{figura:CinderBug} 
\item Una serie de desarrolladores son los encargados de rechazar o aceptar el ticket. Si el ticket se acepta, ciertos valores asociados a él, como 'status' ó 'importance', entre otros, cambian.
\item Aquel desarrollador que crea saber como se puede solucionar el problema/necesidad que se describe en el ticket, se asigna como encargado de resolver dicho ticket. En ese momento aparece Gerrit, proporcionando un hilo de seguimiento para el ticket.
\item En Gerrit, el encargado de solucionar el problema añade dicho parche, que no es más que código añadido al código fuente. Este código debe pasar unos tests y ser aprobado por varios desarrolladores encargados de supervisar que el cambio propuesto no dañe al programa.  Ver imágen ~\ref{figura:Gerrit} 
\item Una vez que el código es aceptado por los desarrolladores y pasa las pruebas de test, se incorpora al código almacenado usando Git. 
\end{enumerate}

Puede suceder también que en algunos casos, los tickets abiertos no sean aceptados, sean abandonados ó sean asignados a varias personas a lo largo del ciclo del ticket.

En la figura \ref{figura:flujo} aparece el flujo de trabajo que usa OpenStack entre cada una de las herramientas.
\begin{figure}
    \centering
    \includegraphics[scale=0.6]{img/workflow}
    \caption{flujo de trabajo en OpenStack}
    \label{figura:flujo}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{img/CinderBug}
    \caption{Aspecto de los tickets en Cinder}
    \label{figura:CinderBug}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{img/Gerrit}
    \caption{Aspecto de Gerrit para un ticket}
    \label{figura:Gerrit}
\end{figure}

\subsection{Launchpad}
\label{sec:launchpad}
Es una plataforma, lanzada por Canonical Ltd. en Enero de 2004, de desarrollo colaborativo de software libre. 
Es un servicio gratuito con una interfaz web desde que permite ver reportes de errores, en caso de que quisieras reportar, comentar o subir nuevos errores deberías registrarte como usuario. Nos referiremos a estos reportes en secciones posteriores como tickets. 

Launchpad\footnote{\url{https://launchpad.net}} consta de varios componentes
\begin{itemize}
    \item Code: Aloja el código fuente usando un sistema de control de versiones.
    \item Bugs: Permite un sistema de seguimiento de errores para informar sobre errores o bugs en diferentes distribuciones y productos. 
    \item Blueprints: Sistema de seguimiento usado para nuevas características, funcionalidad ó procesos. 
    \item Translations: Sistema destinado a la traducción de aplicaciones.
    \item Answers: Foro destinado a la ayuda de la comunidad, en él se resuelven dudas planteadas.
\end{itemize}

Cada proyecto dentro de OpenStack tiene su propia página en Launchpad, la figura ~\ref{figura:LaunchpadCinder} muestra la página que usa Cinder en Launchpad\footnote{\url{https://launchpad.net/cinder}}

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{img/LaunchpadCinder}
    \caption{Repositorio Cinder}
    \label{figura:LaunchpadCinder}
\end{figure}
 
\subsection{Git}
\label{sec:git}
Git\footnote{\url{https://git-scm.com}} es un sistema de control de versiones distribuido escrito originalmente en C y desarrollado por Linus Torvalds y otros colaboradores para manejar el kernel de Linux. Distribuido significa que no hay ninguna copia central del repositorio .
 
Git es un sistema abierto y de código libre diseñado para manejar proyectos de pequeña y gran envergadura con alta eficiencia y velocidad. Se diferencia de otros sistemas de control de versiones en la forma en que modela sus datos. Git modela los datos como si se tratase de un conjunto de instantáneas de un pequeño sistema de archivos. De tal forma que cada vez que confirmas un cambio ó guardas el estado de un proyecto Git, internamente lo que se está realizando es una instantánea del aspecto que tiene todos sus archivos en ese momento, guardando una referencia a esa instantánea. 

Consigue ser eficiente debido a que no almacena archivos nuevos si no han sido modificados, sólo almacena un enlace al archivo idéntico de la versión anterior, que ya tiene almacenado ver figura ~\ref{figura:GitVersions}. La rapidez que demuestra Git en su manejo se debe a que la mayoría de operaciones que realiza son locales, generalmente no necesita información de ningún otro ordenador de la red. De tal forma que, para navegar por la historia del proyecto, no necesitamos salir al servidor para obtener la historia y mostrarla, si no que la lee de la base de datos local.

En Git, toda operación es verificada, antes de ser almacenada, a través de un \textit{'checksum'} ó suma de comprobación, esa operación es identificada con dicho checksum. Esto quiere decir que no se puede cambiar ningún contenido sin que Git se entere.

Un factor clave para nuestra investigación es que en Git no se borra información. Esto se debe a que generalmente, las acciones de Git sólo añaden información a la base de datos. Es realmente difícil conseguir que el sistema haga algo que no se pueda revertir, al menos que los cambios no hayan sido confirmados. Es esto lo que queremos para nuestro estudio ya que nos interesa ver toda la evolución del código en las distintas versiones. 

\begin{figure}
    \centering
    \includegraphics[scale=0.6]{img/GitVersions}
    \caption{Almacenamiento de la información como instantáneas a lo largo del tiempo}
    \label{figura:GitVersions}
\end{figure}

\subsection{Gerrit}
\label{sec:gerrit}
Cuando muchos desarrolladores trabajan en un mismo proyecto, el código se ve sometido a constantes cambios que pueden provocar que la  \textit{build} se rompa, este es uno de los problemas que tiene Git, ya que su desarrollo es en raíz o trunk, dónde pueden coexistir lineas de desarrollo denominadas como  \textit{trunk} (tronco) y  \textit{branchs} (ramas). 

Git no permite un control centralizado por tanto, no permite bloquear cambios que puedan dañar la \textit{buid}, y se recurre a sistemas como Github\footnote{\url{https://github.com}} ó Gerrit\footnote{\url{https://code.google.com/p/gerrit/}} para conseguir estas funcionalidades. 

Gerrit es una herramienta gratuita de revisión de código colaborativa a través de una Web, para los sistemas de control de versiones de Git, donde el propio Gerrit es un repositorio Git remoto que actúa como intermediario. De esta forma, cada vez que se produzca un cambio, el código se subirá a Gerrit y no a Git, y es dentro de Gerrit donde se revisan los cambios propuestos, si cumplen las características y no rompen el \textit{build} se aprueban, si sucede lo contrario, estos cambios serán rechazados.

Con Gerrit, tendríamos nuestros repositorios Git en local y un repositorio remoto albergado en sitios como Github, desde dónde haríamos push y pull para recoger o enviar los cambios.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TECNOLOGêAS USADAS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Tecnologías Usadas}
\label{sec:Tecnologias}
Esta sección se encuentra dedicada a las tecnologías que se han visto envueltas en la creación de nuestra herramienta. La herramienta hace uso de dos tecnologías principales, la primera del lado del cliente es HTML5 que agrupa las nuevas tecnologías de desarrollo de aplicaciones web como HTML5, CSS3, Bootstrap y nuevas capacidades de JavaScript, y la segunda tecnología es Node.js usada como servidor. 

\section{Tecnologías usadas en el Navegador} 
\label{sec:clientSide}
A continuación se describen cada una de las tecnologías que son usadas en la herramienta desde el navegador y que forman lo que se conoce como el lado del cliente.

\subsection{HTML5} 
\label{sec:html5}
Es la quinta versión de del lenguaje HTML, lenguaje utilizado para la creación de páginas web que se encuentra regulado por el Consorcio W3C.

En las webs actuales que usan HTML5\footnote{\url{https://developer.mozilla.org/es/docs/HTML/HTML5}}, se pueden encontrar etiquetas y atributos nuevos, así como nuevas funcionalidades como son audio y video. Algunas etiquetas han sido eliminadas y otras como la etiqueta  \textit{canvas}  ha sido mejorada, permitiendo renderizar elementos 3D en los navegadores Chrome, Firefox, Opera, Safari e Internet Explorer. 

La versión 5 de HTML es completamente compatible con la versión anterior, HTML4, de tal manera que las webs que usan HTML4 segurán funcionado en HTML5. Antes de HTML5 se usaba la tecnología Flash para proporcionar al navegador  de audio, video, webcams, animaciones vectoriales \ldots Ahora con HTML5 no serán necesarios más plugins. 

\subsubsection{Novedades}
\label{sec:Novedades}
 \begin{itemize}
    \item Incorpora etiquetas con codecs para mostrar los contenidos multimedia.
    \item Incorpora mejoras en los formularios, creando nuevos tipos de datos como  \textit{eMail, number, url, datetime \ldots} 
    \item Incorpora una nueva funcionalidad  \textit{Drag \& Drop} que permite arrastrar objetos como si fuesen imágenes.
    \item Incorpora etiquetas para manejar grandes conjuntos de datos.
    \item Añade etiquetas como  \textit{header, footer, article }... para manejar la Web Semántica.
    \item Incorpora una nueva API de Geolocalización para los dispositivos que la soporten.
    \item Incorpora una API Storage que nos da la posibilidad de almacenamiento persistente en local.
    \item Incorpora una API para la comunicación bidireccional entre páginas, llamada WebSockets.
\end{itemize}

\subsection{CSS3} 
\label{sec:css3}
Es la tercera versión de las hojas de estilo en cascada o CSS, mediante estas hojas podemos definir las reglas y los estilos de representación en diferentes dispositivos capaces de mostrar contenidos web. El manejo de CSS es imprescindible para cualquier desarrollador web, ya que le permite definir y diseñar de manera eficiente la representación de la página. El Objetivo principal de CSS es separar el contenido de la forma.

A partir del año 2005 se comenzó a definir CSS3, y actualmente esta versión nos ofrece una amplia variedad de opciones que cubren las necesidades de cualquier diseñador web. Actualmente, CSS3 aporta más control sobre los elementos de la página, introduce nuevos mecanismos con los cuales dejamos de recurrir a trucos que normalmente complicaban el código de la web.

En la url\footnote{\url{http://www.css3.info/preview/}} se encuentra detalladas todas las características que nos ofrece CSS3, a  continuacón listaremos brevemente algunas de ellas.

\subsubsection{Novedades}
\label{sec:NovedadesCSS}
 \begin{itemize}
    \item Bordes: Aparece la posibilidad de definir colores a los bordes, añadirles a los bordes imágenes, diseñar bordes redondeados ó crear sombras a los elementos de la página.
    \item Fondos: Aparece la posibilidad de decidir la posición de la imagen de fondo con respecto al borde ó conseguir que un elemento tenga varias imágenes de fondo a la vez.
    \item Color: Aparecen los colores RGBA y la opacidad.
    \item Texto: Aparece la posibilidad de aplicar sombras ó distintos efectos en los textos y usar cualquier tipografía en una página web.
    \item Interfaz: Aparece la posibilidad de cambiar el modelo de caja por defecto ó desplegar el menú según tus necesidades.
    \item Selectores: Aparecen los selectores por atributos
    \item Degradado: Aparece la posibilidad de insertar degradados, ya sean lineales, radiales\ldots
    \item Animaciones: Aparece la posibilidad de realizar efectos que sólo estaban disponibles con otros tipos de tecnologías.
\end{itemize}

\subsection{Bootstrap} 
\label{sec:bootstrap}
Fué desarrollado inicialmente en el año 2011 por el equipo de ingeniería de Twitter, para resolver las inconsistencias en el desarrollo web. Fomentando así la utilización del mismo framework para minimizar inconsistencias, minimizando de esta manera los fallos y aumentando tanto el flujo de trabajo como la eficacia. 

En Agosto del 2011 se lanzó al público como un proyecto Open Source en Github, lo que siguió fue una enorme colaboración por parte de miles de desarrolladores, convirtiéndose así en uno de los proyecto Open Source más activos a nivel mundial. Día tras día, Bootstrap gana notoriedad hasta tal punto que ha llegado a convertirse en uno de los framework CSS má famoso y más utilizado.

Bootstrap es una colección de elementos y funciones web como HTML, CSS y JavaScript que pueden personalizarse, están empaquetadas y son accesibles a através de una herramienta. Nos permite crear interfaces de usuario adaptables a cualquier dispositivo y  pantalla.

Actualmente se encuentra en la version 3.3.5, pero desde la version Bootstrap 3 lanzada en Agosto del 2013, se ha mejorado el diseño, personalización y la gestión de errores. Es totalmente compatible con los navegadores  \textit{Google Chrome, Safari, Mozilla Firefox, Internet Explorer y Opera}.
\subsubsection{BootStrap 3}
\label{sec:Bootstrap3}

Esta versión nos aporta una gran variedad de nuevas características como son:
\begin{itemize}
    \item Soporte casi completo con HTML5 y CSS3.
    \item Sistema Grid que permite diseñar la web usando un Grid donde el contenido es plasmado.
    \item Media Queries que permiten de forma fácil variar la web dependiendo del tamaño del dispositivo.
    \item Insertar imágenes que pueden adaptan su tamaño.
\end{itemize}

\subsection{JavaScript} 
\label{sec:javaScript}
JavaScript\footnote{\url{https://developer.mozilla.org/es/docs/Web/JavaScript}} es un lenguaje de programación, lenguaje de scripting multiplataforma y orientado a objetos, utilizado principalmente en la creación de páginas web dinámicas. 
Ahora bien, ¿Qué es una página web dinámica?. Es aquella que incorpora efectos como texto que aparecen y desaparecen, incluye animaciones, acciones activadas a través de botones y ventanas de avisos dirigidas hacia el usuario.

En el lenguaje JavaScript no es necesario compilar los programas, puesto que es un lenguaje de programación interpretado. Es decir, podemos usar cualquier navegador para probar nuestros programas, sin necesidad de procesos intermedios.

Principalmente, el uso de JavaScript se encuentra en el lado del cliente, permitiendo mejoras en la interfaz de usuario. En sus inicios solamente se podían realizar operaciones en el marco de aplicacón del cliente, pero actualmente y gracias a tecnologías como AJAX, puede enviar y recibir información del servidor. 

\subsubsection{Historia}
\label{sec:historiaJS}
En los años 90 debido a la baja velocidad de los módems y a la incrusión de formularios en las páginas webs surgió la necesidad de crear un lenguaje de programación que se ejecutase en el navegador del usuario reduciendo así el tiempo de espera en caso de error en el formulario. 

La solución a este problema la encontó Brendan Eich, programador que trabajaba en NetScape, adaptando tecnologías existentes como ScripEase al navegador Netscape Navigator 2.0. Este lenguaje fue denominado inicialmente como LiveScript.

Posteriormente, Netscape firmó un acuerdo con Sun Microsystems para desarrollar un nuevo lenguaje de programación, al que llamaron JavaScript justo antes de ser lanzado. Razón meramente comercial ya que la palabra Java estaba de moda en aquella época.

La primera versión de JavaScript fué un éxito, tanto que Microsoft la copió bajo el nombre de Script y la incluyó en su navegador Internet Explorer 3.

En 1997, Netscape dedició estandarizar el lenguaje JavaScript y evitar de esta forma una guerra de tecnologías. ECMA  \textit{European Computer Manufacturers Association} creó el comité TC39 con el objetivo de estandarizar un lenguaje de script multiplataforma e independiente de cualquier empresa. El primer estándar se denominó ECMA-262, en el cual se definió por primera vez el lenguaje ECMAScript. Por tanto, JavaScript no es más que la implementación que realizó Netscape del estándar ECMAScript. 

\subsubsection{Características}
\label{sec:JsCaracteristicas}
Para integrar JavaScript en documentos XHTML solamente es necesario encerrar el código JavaScript entre las etiquetas  \textit{script} e incluirlas en cualquier parte del documento. Para que la página XHTML sea válida, se necesita añdir el atributo type a la etiqueta  \textit{script}, ya que los valores que incluye type se encuentran estandarizados,  \textit{text/javascript} es el valor correcto para el caso de JavaScript. También tenemos la posibilidad de definir el código JavaScript en un archivo externo y enlazarlo mediante la etiqueta  \textit{script} en el XHTML, añadiendo el atributo src, indicando la ruta hacia el archivo, a la etiqueta   \textit{script.} 

Las principales características que posee JavaScript son:

\begin{itemize}
    \item Tipado Dinámico: El tipo de la variable se encuentra asociado al valor y no a la variable ya que se trata de un lenguaje scripting. De esta forma podemos tener una variable, x, ligada a una cadena de caracteres y posteriormente, relegada a un valor float. 
    \item Objetual: JavaScript estaá formado mayoritariamente por objetos, Estos objetos son arrays asociativos, mejorados con la inclusión de prototipos. En tiempo de ejecución podemos crear, cambiar o eliminar las propiedades y sus valores.  
    \item Evaluación en tiempo de ejecución: Existe una función eval que permite evaluar expresiones en tiempo de ejecución
    \item Funciones de primera clase: A las funciones se le suele conocer como ciudadanos de primera clase; son objetos en si mismos. Por ello, como objetos que son, posee propiedades y métodos. Existe la posibilidad de anidar funciones. Y aparece el término de clausura ligado a la invocación de funciones externas.
    \item Prototípos: En JavaScript se usan prototipos en lugar de clases para el uso de herencia.
    \item Funciones como constructores de objetos: Las funciones se pueden comportar como constructores, creando instancias de un prototipo, heredando propiedades y métodos del constructor.
    \item Entorno de ejecución: Normalmente, JavaScript depende del entorno en el que se ejecute para poder ofrecer objetos y métodos.
    \item Funciones como métodos: No existe diferencia entre la definición de función  y la definición de método. Una función puede ser llamada como un método de un objeto, usando la palabra clave this como variable local a la función que representa al objeto que la invocó.
\end{itemize}

\subsection{jQuery} 
\label{sec:jquery}
jQuery\footnote{\url{https://jquery.com}} es una de las biblioteca de JavaScript más utilizadas, creada el 26 de agosto de 2006 por John Resig, tiene como propósito facilitar la manera de interactuar con los documentos HTML, manipular el árbol DOM , manejar eventos y agregar la interacción con la técnica AJAX a páginas web .

JQuery es software libre y de código abierto, ofrece funcionalidades, 'atajos', basadas en el lenguaje JavaScript, logrando grandes resultados en un menor tiempo y ocupando menos espacio de código.

Consiste en un único fichero JavaScript con las funcionalidad comunes del DOM, eventos, efectos y AJAX. Su característica principal es que a través de peticiones AJAX y manipulando el árbol DOM, podemos lograr que el contenido de la web cambie sin necesidad de recargar la página.

La forma de interactuar con la página es usando la función jQuery(), normalmente se identifica con el alias \$(). Esta función nos permite acceder a los elementos del DOM, recibe como parámetro el nombre de una etiqueta HTML ó una expresión CSS y devuelve todos los elementos del DOM que cumplan la expresión. Las funciones que proporciona la biblioteca pueden ser aplicadas a cualquiera de los nodos que nos devuelva la función. 

Para usar jQuery lo único que debemos hacer es añadir la librería de jQuery a nuestra página, la librería puede ser descargada previamente ó incluida desde uno de los servidores de Google que nos la ofrece. 

\subsection{GitHub.js}
\label{sec:github.js}
Github.js es una librería de JavaScript que nos proporciona un 'envoltorio' de alto nivel entorno a los comandos de git. Cuenta con una API diseñada para manipular los repositorios de GitHub a nivel de archivo.

Si queremos trabajar con esta biblioteca, debemos proporcionarle acceso a la API  \textit{HTTP} de GitHub mediante un protocolo de autenticación. Para ello, se requiere generar un token que será utilizado junto con el mecanismo de autenticación OAuth, mecanismo soportado por esta biblioteca. 

\section{Tecnología usada en el servidor}
\label{sec:servidor}
En esta sección se detalla la tecnología Node.js usada como servidor por la herramienta.
 
\subsection{NodeJS} 
\label{sec:node}

Google desarrolló un interprete ultra rápido escrito en  \textit{C++} para Chrome, pudiendo descargar e incorporar el motor JavaScript  V8 a cualquier aplicación que deseemos, ya que se ejecuta en el navegador. Node hace uso de este motor V8 JavaScript dándole otro propósito para ser usado en el servidor. 

Node\footnote{\url{https://nodejs.org/en/docs/}} es una plataforma reciente, basada en ejecutar JavaScript en el lado del servidor. Tiene el concepto de agregar módulos a su mismo núcleo. Hay cientos de módulos que se pueden agregar a Node, y si no existe, podríamos desarrollarlo.

En el lado del servidor, la programación es orientada a eventos, estos eventos no se inician de la misma forma que en el lado del cliente ya que no se pulsan botones o se inserta texto, pero a un nivel superior, lo que se está ejecutando son eventos. En el lado del servidor, los eventos se inician con  \textit{"streams"} o flujo de datos entrantes, cuando se realiza una conexión, cuando se está recibiendo datos a través de esa conexión o cuando se dejan de recibir datos.

\subsubsection{Características}
\label{sec:nodeCaracteristicas}

Node cambia la forma en la que una conexión es realizada con el servidor, de tal forma que en vez de generar un nuevo hilo para cada conexión, lo que se dispara en cada conexión es un evento dentro del proceso del motor de Node. Gracias a esto, Node puede asegurar que soporta decenas de miles de conexiones concurrentes, y nunca se quedará en un punto muerto ya que no permite bloqueos. 

Node ha sido diseñado para soportar gran cantidad de tráfico, con una lógica y procesamiento requerido que no necesita ser demasiado grande en la parte del servidor. 

Node es perfecto para ofrecer:
\begin{itemize}
    \item API RESTful: Podemos implementar un servicio Web que facilita una API RESTful, de la cual toma unos parámetros y los interpreta, devolviendo la respuesta al usuario, normalmente una cantidad pequeña de texto. No requiere una cantidad de lógica,. por tanto pude construirse para dar servicio a multitud conexiones.     \end{itemize}

Node implementa los protocolos de comunicación más habituales en redes, tales como  \textit{HTTP,DNS, TLS, SSL}, etc.

Algunos ejemplos de empresas que usan Node son LinkedIn, la empresa ha reducido el número de servidores que tenían funcionando al pasar a usar NodeJs. Otras de las empresas que han optado por usar Node son  \textit{Microsoft, eBay} ó la red social  \textit{Geekli.st}.

\subsubsection{Tecnologías y frameworks basados en NodeJS}
\label{sec:frameworksNode} 
Existen diversos proyectos muy interesantes cuyo funcionamiento esta basado en Node, a continuación los comentaremos:

\begin{itemize}
    \item Meteor JS: Es un framework destinado a crear aplicaciones Web programado en JavaScript, se ejecuta sobre el motor de NodeJs.
    \item SocketStream: Es un framework diseñado para soportar aplicaciones de una Web en tiempo real ó Realtime SPAs,  \textit{Single Padge Apps}. Más enfocado hacia el cliente, permite usar plantillas y módulos en el lado del cliente.
    \item Yeoman: Es una herramienta que simplifica la tarea de crear proyectos, ofrece multitud de utilidades basadas en librerías y frameworks habituales como Bootstrap, BackboneJs\ldots 
\end{itemize}
   
\section{Tecnologías de intercambio de datos}
\label{sec:intercambio}
En esta sección se detalla las tecnologías que son usadas como forma de intercambio entre el cliente y el servidor.

\subsection{JSON}
\label{sec:json}
JavaScript Object Notation ó JSON, es una alternativa a XML en AJAX, que permite representar estructuras de datos en formato ligero para el intercambio de datos. Al requerir menos caracteres para representar la misma información, consume menos ancho de banda.

Una de las grandes ventajas que aporta este formato, a parte de consumir menos ancho de banda, es que parsearlo es mucho mas sencillo. Es decir, escribir un analizador sintáctico requiere menos esfuerzo si usamos un texto JSON, es más, existen funciones como  \textit{'eval()'} en JavaScript que sirven para dicho propósito, analizar textos JSON. 

\subsection{REST}
\label{sec:rest}
%La herramienta hace uso de diferentes APIs a través de llamadas a urls, desde el lado del cliente se crean llamadas a su propia API la cual, en ocasiones formula peticiones a otras APIs devolviendo la respuesta procesada en formato JSON hacia el cliente.
La transferencia de Estado Representaciones se conoce como REST, es un estilo de arquitectura software para sistemas hipermedia distribuidos, que son aquellos que permiten contenidos como texto, imagen ó video interactuando con los usuarios.

En REST, lo que se pública son recursos. Cada recurso posee un identificador que lo distingue entre cualquier otro. Poseen un estado interno, al que no se puede acceder desde el exterior directamente. Podemos acceder a representaciones de dicho estado desde el exterior, entendiendo por representación un formato de datos concreto para la transferencia de una copia del estado entre el cliente y el servidor. La implementación del recurso decide que información es visible o no desde el exterior, y que representaciones se soportan. Las representaciones pueden ser documentos XML, HTML o JSON. 

En REST todos los recursos comparten una interfaz única y constante. Todos tienen las mismas operaciones, que nos permiten manipular el estado publico del recurso. La clave de REST es que es un servicio sin estado, lo que quiere decir que entre dos llamadas cualesquiera, el servicio pierde todos sus datos, el estado lo debe mantener el cliente y es él quien debe encargarse de pasárselo en cada llamada. 

En la herramienta se ha implementado un APIRestFul, mediante la cual, a través de eventos programados en el lado del cliente se realizan una serie de llamadas, usando funciones y parámetros, a la API de la herramienta. 

Uno de los principales motivos por los cuales desarrollamos una APIRestful es el problema del \textit{'Cross Domain Call'}. Un Cross Domain Call, es un mecanismo de seguridad de comunicaciones entre los navegadores actuales, evita que un script o una aplicación de una página web pueda acceder a un servidor web diferente del que residen. Debido a que nuestra aplicación necesita extraer información de otros servidores diferentes al que reside, nos vimos obligados a crear la esta APIRestful ,mediante la cual hacemos peticiones a nuestras API y es el servidor quien se encarga de formular las peticiones a las APIs de las webs que no residen en nuestro servidor.
  
\subsection{OAuth}
\label{sec:oauth}
OAuth es un protocolo que permite flujos de autorización para aplicaciones web. Permite a un proveedor de servicios compartir su información con el consumidor, sin la necesidad de compartir toda su identidad.

Es un método que permite interactuar con datos protegidos y publicarlos, proporciona a los usuarios un acceso a sus datos al mismo tiempo que protege las credenciales de su cuenta. Eliminando la necesidad de crear usuario y contraseña para acceder a una web, confiando en que la web use tus credenciales sabiamente y queden protegidas de hackers. OAuth evita este problema, ya que da acceso solamente a lo que el desarrollador permita acceder.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%ESTUDIO  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estudio Realizado}
\label{sec:estudiodone}

En este capítulo nos centramos en describir el estudio de investigación que hemos llevado a cabo, detallando cada una de las dos fases de las que consta. La primera fase denominada como fase de filtrado, se centra en descartar los tickets, que bajo nuestro criterio no son considerados como tickets de error, de aquellos que describen un error. La segunda fase denominada como causa del error, analiza si el commit antecesor provocó la aparición porterior del error. 

\section{El estudio} 
\label{sec:objetivo}

%En esta seción explicaremos en que se basa nuestro estudio, la descripción será más detallada que la proporcionada en capitulos previos. Si queremos saber más acerca del estudio, en los anexos, podemos encontrar un art’culo explicando el estudio empírico que estamos llevando a cabo. Empezaremos introduciendo algunos de los conceptos y familiarizándonos con palabras que serán nombradas continuamente a lo largo de este capítulo.
%
%El objetivo principal es estudiar el número de casos en los que el error ha sido causado por el commit inmediatamente anterior. Entendiendo por commit un cambio realizado en el código fuente que lleva asociado un identificador único.  A causa de la falta de evidencia empírica que encontramos en la literatura actual acerca del tema que queremos tratar, 
Hemos realizado un estudio observacional que engloba el análisis de 100 tickets extraídos del repositorio de Cinder. Un ticket es el nombre que se da a la evolución escrita sobre un error encontrado en el código, y se reporta con un identificador único en el repositorio destinado para ello, en nuestro caso, Launchpad. Cuando hablamos de commit, nos referimos al identificador que muestra un cambio realizado en el estado de ficheros de un repositorio.

El estudio consta de dos fases, la primera fase tiene como objetivo la obtención de una clasificación de los  tickets analizados, dicha clasificación consta de tres categorías: 'Es un error', 'No es un error', y 'No podemos saberlo'. Cada uno de los tickets pertenecerá a una de estas categorías en base a los criterios establecidos y a la opinión personal de los desarrolladores.  
La segunda fase, se centra en el estudio de aquellos tickets que han sido categorizados como 'Es un error'. Obteniendo finalmente una nueva clasificanción de estos tickets acorde con la responsabilidad del commit ó commits antecesores. Dicha clasificación también tiene tres nuevas categorías: 'Es responsable', 'No es responsable' y 'No podemos saberlo'. Es esta última fase la que nos proporcionará los datos necesarios para poder demostrar empíricamente en cuantos casos el commit antecesor es la causa del error en el proyecto de Cinder.

Si queremos saber más acerca del estudio, en el anexo A, podemos encontrar un artículo explicando el estudio que estamos llevando a cabo.

\section{Primera fase ó filtrado}
\label{sec:fase1}

En esta primera fase, colaboran dos desarrolladores realizando el mismo análisis paralelamente, de esta forma la clasificación de cada ticket no se ve involucrada por la opinión ó comentarios de la otra persona. Dicho análisis consta de la extracción aleatoria de 100 tickets residentes en la Launchpad de Cinder cuya url se encuentra disponible en \footnote{\url{https://bugs.launchpad.net/cinder}}. Los tickets poseen diferentes estados dependiendo de su evolución, desde que se reporta un error hasta que alguien arregla el error:

\begin{itemize}
    \item New: Es cuando un ticket acaba de ser notificado en la Launchpad.
    \item Incomplete: Es cuando el informe del error esta incompleto y necesita mas información para poder ser clasificado dependiendo de sus prioridades.
    \item Invalid: Es cuando la notificación del error describe un comportamiento normal del software, o cualquier otro motivo que haga inválido al ticket.
    \item Confirmed: Es cuando un miembro de la comunidad distinto a quien reportó el ticket, acepta la descripción del ticket, en este momento cualquier desarrollador podría trabajar en una solución.
    \item In progress: Es cuando un desarrollador ha tomado la responsabilidad del corregir el error y está trabajando en ello.
    \item Fix Committed: Es cuando un desarrollador ha realizado un commit con la solución al código base del proyecto.
    \item Fix Released: Es cuando una nueva versión del software, con la corrección del error, ha sido lanzada.
\end{itemize}
 
\subsection{Búsqueda y extracción}
\label{sec:busqueda}
Nosotros estamos interesados en aquellos tickets cuyo estado sea  \textit{'Fix Committed'} ó  \textit{'Fix Released'}, ya que solamente en esos casos es cuando el error ha sido arreglado y los cambios realizados en el código son visibles, por tanto restringiremos la búsqueda de los tickets aleatorios a aquellos cuyo estado sea  \textit{'Fix Committed'} ó  \textit{'Fix Released'}. Como ya hemos comentado anteriormente, cada ticket posee un identificador único, con el que reconoceremos al ticket en Launchpad. El ticket contiene toda la información relativa al error que se ha reportado, como por ejemplo el identificador del error en Launchpad, la descripción del error, la persona encargada de arreglar el error ó una serie de comentarios que permiten ver el proceso de evolución del ticket. En la mayoría de los casos, obtenemos además la descripción del commit, el identificador del commit y la url de Gerrit, donde tenemos disponible la revisión del código. 

A pesar de toda la información de la que disponemos en Launchpad, para nuestro análisis en esta primera fase, solamente necesitamos conocer el título y descripción del ticket y la url de Gerrit asociada a este ticket, para extraer de ella toda la información relacionada con el commit que arregló el error como es el identificador del commit, el identificador del commit padre, los ficheros implicados y la descripción del commit. Con toda esta información los desarrolladores deben de ser capaces de clasificar el ticket en una de las tres categorías.

Esta primera fase tiene gran relevancia puesto que es aquí donde separamos los tickets que son error de aquellos que no lo son. Esto es muy importante, ya que nuestro estudio se centra en analizar si el commit inmediatamente anterior ha sido el responsable del error. Por tanto, si lo que analizamos es un ticket en el que no se notifica un error, el estudio será erróneo. Por este motivo, a continuación detallaremos cada uno de los campos de información extraídos para ayudarnos a tomar la decisión en ésta primera clasificación.
                                                 
Normalmente, un buen ticket debería tener un titulo claro, una descripción detallada sobre lo que actualmente está fallando, y una descripción, que iría ligada al commit, en la que se detallase cual ha sido la solución que ha arreglado el error. Cuando nos encontramos con tickets que cumplan lo anteriormente mencionado, podemos estar seguros de que el ticket realmente notifica un verdadero error. En la imágen ~\ref{fig:description} se puede apreciar la visualmente la buena descripción de un ticket de error. Ya que se observa que en la descripción del título aparece una palabra que nos puede indicar que se trata de un error, pero es en la descripción cuando efectivamente corroboramos que se trata de un error puesto que describe detalladamente que es lo que está fallando y además, propone una solución.  
Pero no siempre es tan sencillo como lo descrito anteriormente, ya que suele ser común encontrarnos la misma descripción para el ticket y para la descripción del commit, en esos casos, tendremos que revisar detalladamente el código, analizando el estado de los ficheros implicados antes y después de que el posible error fuera solucionado. Para ello, será necesario obtener el identificador del commit que realiza el parche y el identificador de su commit padre. El commit padre no es el commit previo, puesto que esté se refiere a la última modificación realizada en las líneas que supuestamente contienen el error antes de su arreglo. Cuando hablamos de commit padre, nos referimos al último commit realizado que involucra cualquier línea de un fichero antes de arreglar el error, por tanto no tiene porqué coincidir con el commit previo.

\begin{figure}
  \centering
   \includegraphics[scale=0.5]{img/Description}
  \caption{Ticket claramente clasificado como 'Es un error'}
  \label{fig:description}
\end{figure}

\subsection{Metodología}
\label{sec:metodologia}
A continuación detallaremos como obtener la información manualmente, a estas alturas ya sabemos que cada ticket posee un identificador único en Launchpad, nos referiremos a él como  \textit{'n\_ticket'}. Con este identificador, podemos obtener toda la información acerca del error en la web \footnote{\url{https://bugs.launchpad.net/cinder/+bug/n_ticket}}. El titulo, el identificador del commit y la url de Gerrit asociada a ese ticket, a veces puede encontrarse dentro de un comentario en la misma página bajo el titulo de  \textit{'Fix merged to cinder (master)', 'Fix proposed to cinder (master)'} ó  \textit{'Fix merged to cinder (\{Branch\})'}, el título depende del estado del commit dentro del repositorio. En alguna ocasión, el problema descrito en el ticket afecta a varios componentes de OpenStack y no siempre se añaden los parches a todos los repositorios de dichos componentes, por tanto podemos encontrarnos con tickets que no nos proporcionen la url de Gerrit en Cinder.  

OpenStack nos proporciona una interfaz web donde encontramos el Gerrit Code Review system, ahí podemos encontrar los cambios propuestos y revisarlos en \footnote{\url{https://review.openstack.org/ }}. Concretamente, podemos encontrar la revisión del código para cada 'n\_ticket' que queremos analizar en \footnote{\url{https://review.openstack.org/#/c/n_review}}, donde 'n\_review' es el identificador de revisión único para cada \textit{'n\_ticket'}. En la revision del código se muestra toda la información acerca del parche que arregló el error. 

\subsection{Clasificación}
\label{sec:clasificacion}
Este estudio puede ser considerado como un estudio empírico a baja escala, puesto que solamente se analizan 100 tickets, uno de los principales motivos para no realizar el estudio con un número elevado de tickets fue el carácter manual que tenía la investigación es sus inicios. Los desarrolladores eran los encargados de analizar los tickets manualmente hasta encontrar la metodología apropiada, a pesar de que solamente se han analizado 100 tickets, se encontraron muchas diferencias entre ellos en cuanto a extraer datos ó incluso tomar decisiones. Debido a este motivo, nos vimos obligados a definir unos criterios básicos, que dan respuesta a posibles situaciones analizando un ticket. 

A continuación se describe como actuar si nos encontramos ante alguna de estas situaciones, explicando el motivo que nos ha llevado a definir ese criterio.

\begin{itemize}
\item ¿El commit sólamente ha modificado ficheros de tests? No es un error. Uno de nuestros criterios marca que no debemos analizar los ficheros de test, ya que comprendemos que cada modificatción que se realiza en el código debe llevar asociada su correspondiente comprobación, es decir, código que compruebe que funciona, dandole consistencia al programa. El repositorio de Cinder, existe un directorio con el nombre de 'tests' y es bajo ese directorio donde se encuentran los ficheros con el código que realiza las comprobaciones. Por tanto, entendemos que si algo falla solamente en los ficheros de test, se debe a que el error se encuentra en el código del fichero de test y no en los ficheros del programa. Por esta misma razón, los ficheros de test que se encuentren involucrados en un commit no serán analizados y por tanto no los incluiremos como parte de la investigación.
\item ¿Si el ticket notifica una nueva funcionalidad? No es un error. No consideraremos las nuevas funcionalidades como errores, bajo nuestro criterio no es un fallo del programa, si no una mejora. Algunas personas podrían pensar que la falta de algunas funcionalidades en el programa implica un error, por eso lo notifican en un ticket. Pero esa no es es nuestra creencia, y por tanto no lo consideraremos como un error. 
Ademas de las nuevas funcionalidad, todos aquellos tickets que notifiquen optimización del código ó eliminación de código muerto estarían bajo los mismos criterios que las nuevas funcionalidades. 
\item ¿El título del ticket describe un comportamiento inesperado? Es un error. Ocasionalmente, el ticket describe un comportamiento inesperado en funcionalidades que no afectan al comportamiento general del programa. Por este motivo podríamos pensar inicialmente que si no afecta al funcionamiento principal del programa no es un error, pero hemos decidido que lo consideraremos como un error, puesto que se se ha llegado a implementar algo y después no funciona como se espera, es un error, a pesar de que no afecte al funcionamineto general del programa. 
\item ¿El título del ticket describe que se requieren actualizaciones? Es un error. La naturaleza del código es evolucionar, por tanto lo mas normal es que el código necesite ser actualizado, evolucionar en versiones, etc. En esos casos, consideraremos que el ticket está notificando un error ya que si no se actualiza, el programa no funcionará adecuadamente y causará errores.
\end{itemize}

En ocasiones, y debido quizás a la falta de experiencia, falta de conocimientos sobre el tema descrito en el ticket ó la escasez de información obtenida, no seremos capaces de decidir si un ticket es un error o no lo es, por ese motivo tenemos el tercer grupo llamado 'No podemos saberlo', en este grupo se encontrarán todos aquellos tickets que son difíciles de clasificar.

Una vez que ambos desarrolladores acabaron de analizar y clasificar cada uno de los 100 tickets, los resultados deben ser comparados y comentados por ambas partes. Ambas clasificaciones puede tener tres posibles estados de similitud referente a cada ticket, estos estados son:
\begin{itemize}
\item Estado de similitud idéntica: Se da cuando ambos desarrolladores coinciden en su clasificación sobre un ticket. 
\item Estado de similitud moderada: Se da cuando uno de los desarrolladores ha clasificado el ticket bajo la etiqueta 'No podemos saberlo', mientras que el otro ha optado por una de las otras dos categorías.
\item Estado de similitud crítica: Se da cuando ambas clasificaciones para un mismo ticket son contrarias, es decir, un desarrollador lo clasifico como 'Es un error' mientras el otro optó por clasificarlo como 'No es un error'.
\end{itemize}

Uno de los objetivos de este estudio es obtener resultados fiables, por tanto decidimos que la clasificación final fuese obtenida comparando las dos clasificaciones anteriores. De esta forma, en los tickets con similitud moderada y con similitud crítica, ambos desarrolladores deben debatir argumentando sus posiciones y llegar de esta manera a una conclusión final. Si por el contrario, no eran capaces de llegar a ningún acuerdo en alguno de los tickets, se propuso albergar ese ticket en la categoría 'No podemos saberlo'.

En la comparativa de los resultados de clasificación, se dieron 80 estados de similitud idénticos, 16 estados de similitud moderada y 4 de similitud crítica. Después de debatir sobre aquellos tickets en los que ambos desarrolladores diferían, se llegó a un acuerdo en 13 de los casos, mientras que para 7 de ellos las opiniones de cada desarrollador seguían siendo diferentes. 

Tras esta fase, obtenemos una primera clasificación, cuyos datos se presentan y se comentan en la sección ~\ref{sec:resultadosF1}

\section{Segunda fase ó causa del error}
\label{sec:fase2}

En la segunda fase, solo nos centraremos en los ticket que hayan sido clasificados dentro del grupo 'Es un error', ya que de esta forma nos estamos asegurando que todo el análisis posterior es válido. Además, asumimos el error que estamos cometiendo al no tener en cuenta los ticket del grupo 'No podemos saberlo' , ya que puede suceder que hayamos clasificado tickets que notificaban errores de verdad en este grupo. Aún así, decidimos obviar a ese grupo ya que el porcentaje de tickets pertenecientes a él es bajo, entorno al 16\%, por tanto creemos que no sería de suma importancia tenerlos en cuenta en los resultados finales pero asumimos estar cometiendo un error. 

\subsection{Análisis del código}
\label{sec:analisis}
A partir de este momento, la parte más difícil comienza. Nos centraremos en analizar los commits involucrados e identificar la causa del error. Para ello, tenemos que identificar los ficheros involucrados y dentro de ellos, las líneas que han sido modificadas, eliminadas ó añadidas.

Cuando hablamos de líneas añadidas, entendemos que son líneas que antes de solucionar el error no se encontraban en el/los fichero/s pero con el fin del arreglar el error, han tenido que ser añadidas. Lo mismo sucede con las líneas eliminadas, para solucionar el error, los desarrolladores encargados del ticket han tenido que eliminar líneas del código. Hasta este momento no hay ninguna duda para poder identificar estas líneas, el problema comienza al intentar identificar líneas que han sido modificadas, ya que el concepto de línea modificada puede ser confuso. 

En el código pueden realizarse multitud de cambios que impliquen una modificación, por eso debemos dejar claro que es lo que nosotros entendemos por código modificado en este estudio. Para nosotros, el código modificado engloba aquellas líneas en las que cambia algo, el nombre de una variable, las condiciones del bucle, los argumentos de la función\ldots etc. Pero no entendemos que el código haya sido modificado en aquellos casos en los que se borra código de un lado para añadirlo en otro sitio, ó incluso cuando se elimina código para volverlo a escribir idénticamente. A pesar de nuestros pensamiento a cerca de lo que entendemos por código modificado, el uso de la herramienta \textit{Diff}, nos complica demasiado poder diferenciar el código modificado según nuestro concepto, ya que considera los últimos casos descritos anteriormente como código modificado, por tanto, en nuestro análisis, tendremos que considerar como código modificado aquellas líneas en las que aparezca código eliminado y código añadido conjuntamente. 

El análisis que se ha llevado a cabo en esta fase, se centra en definir el número de ficheros implicados, el tipo de código que se ha encontrado en dichos ficheros y el número de commits anteriores que se han encontrado. A pesar de que el objetivo es averiguar cuantos de los commits previos implicados en un cambio fueron causantes de insertar el error, hemos decidido analizar las demás características para obtener más información, de esta manera, podríamos tener en cuanta otras variables que nos ayuden en futuros análisis.

Al igual que en la primera fase, en esta también hemos definido ciertos criterios a seguir para identificar la responsabilidad del commit previo ante la insercción de un error. A continuación aparecen algunos casos en los que podríamos encontrarnos antes de analizar el commit, por tanto el criterio a seguir es el siguiente.
\begin{itemize}
\item ¿El ticket notificaba una actualización? No hay responsable. Entendemos que la naturaleza del código es evolucionar, por tanto si se requiere una actualización nadie puede ser el responsable. Y los commits previos que se hayan encontrado quedan exentos de responsabilidad.
\item ¿El commit que arregla en error no se ha llevado a cabo en el repositorio de Cinder? No sabemos si es responsable, ya que el parche se ha ejecutado en otro repositorio que no es el de Cinder, por tanto no tenemos acceso al identificador del commit. En ocasiones esto sucede debido a que el error afecta a varios componentes de OpenStack, y el cambio que arregla el error se ha ejecutado en uno de los repositorios que pertenecen a esos componentes. 
\end{itemize}

Si el ticket no se encuentra en ninguna de las situaciones anteriores, tendremos que analizar los commits implicados y el código en detalle. Para analizar el tipo de código usado en el parche y los ficheros que están involucrados, hacemos uso de Git, sistema de control de versiones distribuido que nos proporciona commandos útiles para el análisis del código.

A continuación se muestran dos claros ejemplos que explican cuando el commit previo insertó el error en la línea ~\ref{fig:responsible} y cuando el commit previo no causó el error\ref{fig:noResponsible}:

En la imagen  ~\ref{fig:responsible} se observa el estado del fichero en tres versiones diferentes, la primera (1) es una vez que el error ha sido arreglado, la segunda (2) es donde se encuentra la línea con el error, y finalmente la tercera versión (3) muestra el estado del fichero antes de que el error se insertase. En la versión (3) se muestra el commit padre del commit previo 31f208423 al arreglo del error, de esta manera podemos asegurarnos de que en ese commit se insertó el error, puesto que usó un string como variable cuando debería haber usado un Booleano para mantener la concordancia con el resto del código. 
\begin{figure}
  \centering
   \includegraphics[height=2in,width=6.8in]{img/responsible}
  \caption{Ejemplo de cuando el cambio insertado en el commit previo,31f208423, causó el error.La versíon del código mas reciente se encuentra a la izquierda (1)}
  \label{fig:responsible}
\end{figure}

En la imagen \ref{fig:noResponsible} se observa el estado del fichero en tres versiones diferentes, la primera (1) es una vez que el error ha sido arreglado, la segunda (2) es donde se encuentra la supuesta línea que contiene el error, y finalmente la tercera versión (3) muestra el estado del fichero antes de insertar la supuesta línea con el error. En esta ocasión, tras analizar los comentarios y el código, no podemos atribuir el commit previo como responsable del error, puesto que en este caso después de actualizar cierta versión en  el código, el nombre del argumento de una variable cambió, provocando de esta manera el fallo en el código. Pero este fallo no se debe a que se insertase ningún error en la línea 323, puesto que antes de actualizar la versión el código funcionaba perfectamente, es decir, en la version (2) el código no tenía ningún error en su contexto. Por tanto, este ejemplo muestra cuando un error es causa de nuevos requisitos en el software y no podemos atribuir al commit previo como causante del error.
\begin{figure}
  \centering
   \includegraphics[height=2in,width=6.8in]{img/noResponsible}
  \caption{Ejemplo donde el commit previo, 0dc91bed, no causó el error. La versíon del código mas reciente se encuentra a la izquierda (1)}
  \label{fig:noResponsible}
\end{figure}

\subsection{Metodología}
\label{sec:metodologia2}
Para empezar nuestro análisis, lo primero que hemos hecho es clonar el repositorio de Cinder localmente, usando el comando  \textit{'git clone'}. Después, hemos elegido uno de los tickets y hemos extraído el identificador del commit que arregló el error, y el identificador del commit padre, es decir, el identificador del commit anterior antes de que el error fuese arreglado. También hemos extraído el nombre de los ficheros que han sido involucrados.  Usamos el comando  \textit{'git checkout id\_commit'} para cambiar entre los diferentes estados de los ficheros. Empezamos en el estado actual, cuando el error ya ha sido arreglado, para obtener el/los identificador/es del commit/s previos al cambio para cada línea afectada en el fichero. Para ello, usamos el comando  \textit{'git blame file'}, así obtenemos el commit y el nombre del autor que ha modificado cada una de las líneas del fichero por última vez,  finalmente  guardamos la salida obtenida en un fichero de texto. En segundo lugar, debemos cambiar al estado del fichero antes de que el error fuese arreglado, realizando otro  \textit{'git checkout id\_commitPadre'} y realizamos el mismo procedimiento para acabar comparando los ficheros que hemos guardado con la salida obtenida tras el 'git blame file'.

Una vez que hemos guardado los ficheros tenemos que compararlos para saber en que líneas se encuentran las diferencias entre ambos y así, saber que commits previos son los presuntos responsables del error. Usamos el comando  \textit{'diff fichero1 fichero2'} para mostrar  \textit{linea-a-linea} las diferencias entre los dos ficheros,. Diff es un algoritmo extensamente explicado teóricamente en \cite{ukkonen1985algorithms} y \cite{myers1986ano}, el cual nos proporciona sistemas de gestión de gran cantidad de código fuente. Esta herramienta examina ambos ficheros y nos devuelve los cambios que necesita realizar el primer fichero para coincidir con el segundo fichero, es decir, nos está devolviendo las diferencias entre ellos, mostrándo el número de lineas.

La imagen ~\ref{fig:diff} muestra la salida del comando diff al comparar ambos ficheros, en esta salida se puede ver tres partes diferenciadas. En los recuadros coloreados de azul, aparece el número de línea del primer fichero una letra  \textit{'c'} y el número de línea del segundo fichero. La letra  \textit{'c'} indica que se debe realizar un cambio en dichas líneas de los ficheros. El cambio que se debe hacer en el primer fichero es eliminar las líneas recuadradas en color verde he introducir las líneas  recuadradas en color rojo. Por tanto, ya podemos identificar a los posibles commits antecesores responsables del error, en este caso, para ambas líneas es el mismo commit  \textit{'663eadfb'}.

\begin{figure}
  \centering
   \includegraphics[scale=0.45]{img/diff}
  \caption{Salida que muestra el comando diff entre dos ficheros}
  \label{fig:diff}
\end{figure}

\subsection{Clasificación}
\label{sec:clasificacion2}

Tras seguir el procedimiento descrito anteriormente, obtenemos una lista con los posibles identificadores de commit causantes del error. El siguiente paso es analizar cada uno de los commits y clasificarlos en uno de estos tres grupos, dependiendo de su responsabilidad en la aparición del error. Teniendo en cuenta siempre el momento, y el contexto del projecto, en el que la supuesta linea que contiene el error fué añadida/modificada al código fuente.
\begin{enumerate}
    \item Es el responsable : Cuando tenemos claro que el commit ha provocado el error. Una condición mal escrita, el mal uso de las variables, etc.
     \item No es el responsable: Cuando tenemos claro que el commit no ha provocado el error. Como por ejemplo cambios en las llamadas a la API, el cambio de nombre a una variable, etc. 
    \item No podemos saberlo : Cuando no somos capaces de identificar si el commit ha provocado el error o no. En algunas ocasiones hay demasiados commits previos y la descripción es demasiado vaga como para identificar cual de los cambios causó el error, en otras ocasiones el no ser experto del lenguaje usado y del projecto nos impide saber si el commit previo insertó o no el error. 
\end{enumerate}

Como es normal, un parche realizado en el código para solventar el error, puede tocar varios ficheros y en cada fichero podría estar implicado mas de un commit previo diferente. Por tanto, podemos tener situaciones en las que el responsable del error sea mas de un commit previo.

Una vez que estamos analizando los commits implicados, podríamos encontrarnos en las siguientes situaciones, por ello también debemos dejar claro cual es el procedimiento a seguir.
\begin{itemize}
\item ¿El commit previo es un fork? No podemos saberlo, ya que no podemos identificarle. Un fork es cuando se realiza una copia exacta de un repositorio, el cual podremos usar a partir de ese momento como un repositorio git normal. En otras palabras, se puede entender como una bifurcación de un repositorio, en el cual hasta el fork tienen el mismo estado pero a partir de ahí cada repositorio evoluciona de manera independiente. La razón por la cual no podemos identificar al responsable, se debe a que cuando se realiza un fork, todos los archivos del repositorio son añadidos al nuevo repositorio con un identificador de commit diferente al que tenían. Ese es el motivo por el cual no podemos identificar al responsable a menos que nos cambiemos al repositorio 'padre' y sigamos investigando en él.
\item ¿El commit solo ha modificado comentarios, nombre de las versiones ó a añadido líneas en blanco? No es responsable. Estos son algunos de los ejemplos mas claros sobre cuando un commit no es responsable del error, ya que modificar comentarios o añadir líneas en blanco no alteran el comportamiento del programa.
\end{itemize}

Al igual que en la primera fase, los dos desarrolladores han ido trabajando en paralelo analizando los tickets de error. Una vez finalizado su trabajo, el procedimiento seguido fué el mismo que en la primera fase, ambos desarrolladores compararon sus resultados, obteniendo una clasificación final, aquellos tickets que no eran similares en ambas clasificaciones fueron debatidos y se llegó a un acuerdo.

En esta fase el número de discrepancias antes del anláisis fue más elevado, obteniendo 19 diferencias entre ambas clasificaciones. En 11 de ellas se produjo una similitud moderada y 8 de similitud critica. Teniendo en cuenta que en esta fase la similitud moderada se da cuando opinan lo mismo acerca de la responsabilidad de los commits implicados, pero en una de las clasificaciones aparece algún commit más. Mientras que la similitud crítica se da cuando ambos desarrolladores opinan diferente en cuanto a la responsabilidad de los commits ó cuando el identificador de dichos commits difiere.

Tras debatir ambas discrepancias y volver a revisar el código, en aquellos casos de similitud crítica, se llegó a un acuerdo unánime por ambas partes, y como consecuencia, se obtuvo una clasificación final. Después de obtener dicha clasificación, podemos generar diferentes gráficas jugando con las variables que hemos analizado. Estas gráficas se muestran y se explican en la sección ~\ref{sec:resultadosF2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DESCRIPCIîN DE LA HERRAMIENTA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Descripción de la Herramienta}
\label{sec:DescHerramienta}
En este capítulo va dirigido a la descripción de la herramienta. En la primera sección se describe la arquitectura de la web. La segunda sección está dedicada a enumerar detalladamente los requisitos de la herramienta. La tercera sección, detalla la API que ha sido implementada, y que permite la conexión entre el navegador y el servidor. En la cuarta sección se detalla como se realiza la autenticación en la aplicación. Para acabar, la ultima sección ofrece de forma detallada el funcionamiento de la web. 

\section{Arquitectura} 
\label{sec:arquitectura}

La herramienta implementada consta de dos partes claramente diferencias, el Back-End y el Front-End, ambas partes se comunican a través un API RESTful que nosotros mismos hemos creado atendiendo a nuestras necesidades, el cual ha sido descrito en la sección ~\ref{sec:apiherramienta}, de esta forma obtenemos los recursos que necesitamos en cada momento. 

Nos referimos a Front-End como las estructuras HTML, los estilos CSS e interacciones JavaScript que se encargan de transformar todo 'el diseño' web mediante código que no necesita ser procesado para ejecutarse. Actualmente herramientas como AJAX y Websockets nos permiten comunicarnos con la parte del Back-End. 

Se conoce como Back-End al encargado implementar la capa de datos, trabajando con lenguajes y gestores base de datos como PHP, ASP, JAVA y MySQL, Postgres, SQL Server, MongoDB, respectivamente.  Para ello usa interpretes como NodeJS, que permiten consultas a base de datos remotos, en los que se realizan envío de formularios, inicios de sesión, registros, etc. y se transmite la información a través del código realizado por el Front-End al lado del cliente.  

En nuestra aplicación, el Back-End usa el interprete de NodeJs, actuando como servidor encargando de realizar peticiones a otras APIs, concretamente a la API de Launchpad\footnote{\url{https://api.launchpad.net/1.0.html}} y la API de Gerrit\footnote{\url{https://gerrit-review.googlesource.com/Documentation/rest-api.html}}. También se encargará de atender las peticiones de su propia API, que llegan desde el cliente, enviando toda la información requerida al Front-End en formato JSON. La elección de esta tecnología y no otra como Django o Ruby on Rails recae en mí, ya que me desenvuelvo mejor en el lenguaje javaScript que en python o ruby.

El Front-End de nuestra aplicación tiene varias tecnologías coexistiendo, ya que el estilo y la estructura de la página viene definido por Bootstrap, HTML5 y CSS3, mientras que la funcionalidad de la herramienta es trabajo de JavaScript y sus bibliotecas JQuery y Github.js . Los Request son enviados a través de eventos programados en los botones de los que el usuario dispone, de esta forma, la interfaz de usuario es más amigable e intuitiva, o por lo menos esa es nuestra idea.

La herramienta no dispone de base de datos, pero en su defecto, dispone de un repositorio Git asociado a la aplicación, se encuentra albergado en GitHub. Gracias al uso de algunas librerías de javaScript y tras crear y configurar permisos para que nuestra aplicación use Github, disponemos de una 'base de datos' online, ofreciéndonos una gran ventaja, la alta disponibilidad para ver los datos siempre que lo necesitemos.

En la figura~\ref{fig:arquitectura} se muestra la estructura de nuestra aplicación web (APP WEB)

\begin{figure}
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/arquitectura}
  \caption{Estructura de la herramienta}
  \label{fig:arquitectura}
\end{figure}

\section{Requisitos} 
\label{sec:anecesidades}

La herramienta nos sirve de gran ayuda para nuestro estudio, nos ahorra tiempo de análisis y nos proporciona la integración de varios procesos en una misma aplicación. Pero debe cumplir una serie de requisitos indispensables para que sea de gran utilidad y a su vez, para que la experiencia del desarrollador sea agradable. 

A continuación se enumeraran los requisitos que debe cumplir nuestra herramienta:
\begin{enumerate}
    \item Extraer información de un ticket concreto: La información es aquella obtenida manualmente en el estudio anterior y que nos ayuda a clasificar los tickets.
    \item Obtener el identificador de los tickets de manera aleatoria: De este modo el estudio sigue teniendo un carácter aleatorio sin poseer ningún sesgo previa.
    \item Recursos que permitan al desarrollador expresar su opinión durante el análisis: Para que los desarrolladores puedan tener acceso a las opiniones de otros desarrolladores en relación al análisis de un ticket. 
    \item Guardar la información obtenida y analizada sobre el ticket: Es imprescindible poder guardar los datos de los tickets que acaban de ser analizados.
    \item Visualizar la información almacenada sobre un ticket: La aplicación debe mostrar los datos sobre un ticket que previamente ha sido guardado.
    \item Modificar la información almacenada sobre un ticket: La aplicación debe ofrecer la opción de modificar el análisis de un ticket ya que el desarrollador podría haber cometido un error. 
    \item Visualizar los resultados de clasificación: Esta funcionalidad es requerida para proporcionar al desarrollador una visión general de la primera clasificación de los tickets. 
\end{enumerate}

La aplicación no es mas que una web dinámica en la que disponemos de tres pestañas \textit{'Analyze', 'Statistics'} y  \textit{'Modify'}. Son en estas pestañas  donde se encuentran solventadas las necesidades enumeradas anteriormente. 

\section{API}
\label{sec:apiherramienta}
A continuación pasaremos a describir cada una de las funcionalidades programadas en el lado del cliente que nos proporcionan la información que el usuario necesita.

\begin{itemize}
    \item get(/random): Se usa para la obtención de tickets aleatorios, para ello, el servidor realiza una petición url a la página de Launchpad, la parsea y extrae de ella los primeros 75 tickets, que devuelve en formato JSON.
    \item get(/random/moreTickets): Se usa para la obtención de los siguientes tickets aleatorios, funciona igual que la anterior, pero obteniendo diferentes tickets.
    \item get(/ticket/\{idTicket\}): Se usa para obtener datos referentes a un ticket como son la descripción, el titulo, los comentarios y el link a la Launchpad. Al llegar al servidor, éste se encarga de formular una petición a la API de launchpad usando el identificador del ticket obtenido como parámetro anteriormente.
    \item get(/ticket/\{idTicket\}/messages/) : Se usa para obtener todos los comentarios e los que dispone un ticket. Al llegar al servidor, éste se encarga de formular una petición a la API de launchpad usando el identificador del ticket obtenido como parámetro anteriormente.
     \item get(/ticket/\{idTicket\}/SeeData): Se usa para obtener los datos que han sido almacenados sobre un ticket en un repositorio concreto de Github, haciendo uso de la API de github al llegar al servidor.
    \item get(/tickets/\{nameOfFile\}/statistics): Se usa para obtener el parámetro que hace referencia a la clasificación del ticket que ya ha sido analizado y se encuentra almacenado en el repositorio de Github. Para ello, al igual que en el caso anterior el servidor usa la API de Github para obtener la información.
    \item get(/review/\{numReview\}):  Se usa para obtener la información relativa a la revisión de código de un ticket, como son la descripción de cada uno de los cambios propuestos y el identificador del cambio. Al llegar al servidor, éste se encarga de formular una petición a la API de gerrit usando el identificador dl la revisión de código de un ticket, obtenido como parámetro anteriormente.
    \item get(/commit/\{idCommit\}/files): Se usa para obtener infromación sobre los ficheros que han estado involucrados en el commit. Para ello, el servidor hace una petición a la API de Gerrit usando algunos parámetros obtenidos en esta llamada.
    \item get(/commit/\{idCommit\}/aboutcommit):  Se usa para obtener infromación sobre algunas características relevantes del commit implicado, como son la descripción del mismo o el identificador del commit padre. Para ello, el servidor hace una petición a la API de Gerrit usando algunos parámetros obtenidos en esta llamada.
\end{itemize}

\subsubsection{API Launchpad}
\label{subsec:apilaunchpad}
La API de launchpad se encuentra detallada en\footnote{\url{https://api.launchpad.net/1.0.html}}, a continuación solo se mencionarán aquellas llamadas que hemos usado en nuestra aplicación.
\begin{itemize}
   \item https://api.launchpad.net/1.0/bugs/\{numBug\} : Obtiene en formato JSON todas las características relacionadas con el ticket a través del identificador del ticket 'numBug'
    \item https://api.launchpad.net/1.0/bugs/\{numBug\}/messages: Obtiene en formato JSON cada uno de los comentarios relacionados con el ticket a través del identificador del ticket 'numBug'
\end{itemize}

\subsubsection{API Gerrit}
\label{subsec:apiGerrit}
La API de Gerrit se encuentra detallada en\footnote{\url{https://gerrit-review.googlesource.com/Documentation/rest-api.html}}, a continuación solamente detallaremos aquellas llamadas que han sido usadas en nuestra aplicación.
\begin{itemize}
    \item http://review.openstack.org/changes/\{idGerrit\}/detail : Obtiene en formato JSON todas las características relacionadas con la revisión del cambio a través del identificador asociado a la revision 'idGerrit' de un ticket.
    \item http://http://review.openstack.org/changes/\{idGerrit\}/revisions/\{idPatch\}/commit: Obtiene en formato JSON todas las características del commit asociado a un cambio 'idPatch'  a través del identificador de la revision 'idGerrit' de un ticket.
    \item http://review.openstack.org/changes/\{idGerrit\}/revisions/\{idPatch\}/files: Obtiene en formato JSON todas las características de los ficheros que han estado involucrados en el commit asociado a un cambio 'idPatch'  a través del identificador de la revision 'idGerrit' de un ticket.
\end{itemize}

\section{Autenticación}
En nuestra aplicación es necesario logearnos, y para ello necesitamos tener cuenta en github, otorgando permisos a la aplicación sobre esa cuenta. Necesitamos una clave publica y una clave privada para permitir que nuestra web sea una aplicación de github, así se crea la conexión entre el consumidor y el proveedor. Pero en realidad, esta conexión no es directa, ya que en la aplicación usamos una biblioteca llama \textit{'hello.js'}, que permite el uso del protocolo OAuth a través de una proxy de autenticación. Para ello generamos los identificadores del cliente y el identificador secreto para la aplicación en github. 

Esta biblioteca hace uso de un servicio web definido como \textit{oauth proxy}, realiza la labor de un intermediario, permitiendo que la clave secreta no viaje en el browser si no que se consulte en la base de datos y permita la negociación entre cliente y proveedor. Por tanto, nuestra web pasará la inforamción al proxy para que él permita la comunicación con github y el usuario pueda logearse en nuestra aplicación.

Cabe destacar que lo primero que se ejecuta cuando entramos en la web es la autenticación de la aplicación en Github, permitiendo de esta manera a los desarrolladores, con cuenta en github, visualizar y guardar los datos extraidos. Si el usuario no dispone de cuenta en Github, la autenticación falla pero puede extraer toda la información usando la herramienta, el inconveniente es que no puede usar todas aquellas funcionalidades que dependan de Github, como guardar la información, modificarla, consultarla o extraer las estadísticas actuales

\section{Funcionamiento}
\label{sec:funcionamiento}

En las siguientes secciones, vamos a describir la aplicación web desde cada una de las pestañas disponibles en ella. Es decir, describiendo cada una de las funcionalidades que nos ofrecen los distintos botones que podemos encontrar en la interfaz de usuario. Además de la descripción, se proporcionarán  capturas de pantalla realizadas a la aplicación web en las cuales se que muestran visualmente las funcionalidades que se describen.

La primera captura de pantalla que nos encontramos, imáagen ~\ref{figura:Index}, muestra el aspecto inicial de nuestra aplicación Web. En ella podemos observar en la parte superior a la derecha, las tres pestañas que hemos comentado anteriormente. Por defecto la pestaña \textit{'Analize'} se muestra al abrir la aplicación.
\begin{figure}
    \centering
    \includegraphics[scale=0.4]{img/Index}
    \caption{Aspecto Web inicial}
    \label{figura:Index}
\end{figure} 

  
\subsection{Analyze}
\label{sec:analyze}
En esta sección detallaremos cada una de las funcionalidades que nos ofrecen los botones, así como el contenido que aparece en los formularios disponibles en la pestaña  \textit{'Analyze'} de nuestra aplicación web.

La funcionalidad primordial de la herramienta web desarrollada, se aloja en esta pestaña. Nos vemos en la necesidad de analizar una gran cantidad de tickets para poder proporcionar datos fiables. Para ello, los tickets necesariamente tienen que tener carácter aleatorio, de esta forma eliminamos el posible sesgo que pueda tener los resultados de la investigación debido a nuestra eleción. 

Para poder cumplir este objetivo, la aplicación dispone del botón  \textit{'Start'}.  al clicar sobre dicho botón, a herramienta consulta la página de la Launchpad y extrae de ella los primeros 75 tickets, de los cuales se mostrará el identificador de cada uno al usuario en tres columnas desplegables. Además, internamente se está realizando una consulta al repositorio de GitHub que tenemos asociado a la investigación, en el que se almacenan los tickets que han sido analizados, para mostrarnos que tickets han sido analizados previamente, coloreando el identificador del ticket en verde. %y añadiendo el nombre del desarrollador que lo analizó. 

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{img/RandomTickets}
    \caption{Obtención aleatoria y visualización de los tickets en la web}
    \label{figura:RandomTickets}
\end{figure}

En este punto, el desarrollador tiene tres opciones. La primera, analizar un ticket que no ha sido analizado previamente, es decir, aquellos que no estaán coloreados en verde. La segunda, visualizar los datos que han sido guardados sobre uno de los tickets coloreado en verde. La tercera opción, volver a realizar el análisis de un ticket que ya ha sido analizado previamente.

Si el desarrollador decide seguir analizando otros tickets, debe pinchar sobre el identificador del ticket que desee analizar, éste pasará a colorearse en un tono ámbar, y se mostrará la información relevante acerca de ese ticket en la tabla  \textit{'Ticket Info'}, información extraída de Launchpad acerca de ese ticket. Para obtener la información relativa a la revisión del código, el desarrollador debe pulsar el botón  \textit{'More Info'}, y la tabla  \textit{'Review Info'}se rellenará automáticamente con la información extraída de Gerrit sobre dicho ticket. 

Es en este momento es cuando el desarrollador puede categorizar el ticket en uno de los tres grupos que disponemos, 'Es un error', 'No es un error' y 'No estamos seguros'. Además puede añadir las palabras claves que ha encontrado en el titulo, en la descripción del ticket y en la descripción del commit, así como expresar su opinión. Para ello, la herramienta dispone de unas cajas de texto donde el usuario puede escribir y un selector de categoría. 

En los formularios que han sido rellenados autoáticamente, aparecen enlaces a páginas de interés como son la página de de Launchpad ó la página de Gerrit. Los enlaces aparecen para proporcionar al usuario mayor nivel de información, por si la mostrada le pareciese escasa ó incluso porque necesita visualizar el código que ha sido modificado entre la versión actual y la versión anterior de cada uno de los ficheros implicados para poder llegar a una conclusión. Gracias a esto, el desarrollador tiene a su alcance todo lo que necesita para poder decidir como categoriza el ticket que está analizando.

Las palabras clave o  \textit{keywords} debemos elegirlas cuidadosamente, ya que nos serán útiles en un futuro. En esta fase, de momento nos sirve como una recolección de muestras, las cuales analizaremos en fases más avanzadas. Determinando como influye su presencia en los tickets, para ellos haremos uso de algoritmos de machine learning, con el objetivo de obtener una clasificación automática de los tickets basándonos en la semántica descrita en el titulo, en la descripción del ticket y en la descripción del cambio. 

La figura ~\ref{figura:ProcedimientoTicket} muestra el aspecto final que debería tener la herramienta tras el auto-relleno de los formularios y la opinión del desarrollador.

\begin{figure}
    \centering
    \includegraphics[scale=0.35]{img/ProcedimientoTicket}
    \caption{Datos Extraídos y comentarios del Desarrollador}
    \label{figura:ProcedimientoTicket}
\end{figure}

El último paso para acabar con el análisis del ticket, sería proceder a guardar la información. Para ello se encuentra habilitado el botón  \textit{'Save' }, que transforma los datos situados en los campos de información de la web a un formato JSON, y lo almacena en el repositorio destinado para nuestro análisis albergado en GitHub. Añadiendo un archivo de texto, cuyo contenido son los datos en formato JSON y cuyo nombre es  \textit{NumDelTicket\_NombreDelRevisor}. De esta forma, sabemos quién es ha sido el revisor y cual ha sido ticket que se ha revisado.

En esta pestaña se añade además, la posibilidad de analizar un ticket del cual sabemos su identificador, para ello deberemos rellenar el campo etiquetado como  \textit{Ticket ID} y pulsar el botón  \textit{'Get Info'}, situados en la parte izquierda de la aplicación, ver figura ~\ref{figura:RandomTickets}.

Internamente, lo que se estaá ejecutando tras pulsar sobre el identificador de un ticket obtenido aleatoriamente o sobre el botón  \textit{'Get info'}, es un evento Java Script programado. Este evento hace su primera petición request a nuestra API, obteniendo los campos agrupados en la tabla  \textit{'Ticket Info'}.  La segunda petición request a nuestra a API se realiza cuando pulsamos el botón  \textit{'More Info'}, rellenando así los campos correspondientes a la información que obtenemos del code review (Gerrit).

Ahora, solo falta comentar la otra opción que tiene el desarrollador y de la cual hemos hablado al principio y es pulsar sobre uno de los tickets coloreados en verde. Tras pulsar en el identificador del ticket, podemos volver a realizar el proceso que acabamos de describir para obtener un segundo análisis del ticket, ó podemos visualizar la información guardada sobre ese ticket. Si optamos por lo segundo, lo único que debemos hacer es pulsar el botón  \textit{'See Data'}, y se mostrará en la parte derecha de la web, una tabla con toda la información almacenada en el ticket, como podemos comprobar en la imágen ~\ref{figura:SeeData}.

\begin{figure}
    \centering
    \includegraphics[scale=0.85]{img/SeeData}
    \caption{Visualización de los datos tras pulsar el botón 'See Data'}
    \label{figura:SeeData}
\end{figure}

\subsection{Statistics}
\label{subsec:statistics}

Al pulsar sobre esta pestaña, aparecen unos selectores que muestran el nombre de cada uno de los revisores que ha contribuido en el análisis de los tickets en su primera fase. Al pulsar sobre los selectores, se rellena una tabla de datos con información relativa a los resultados de clasificación de la fase de filtrado. Podemos entenderlo como las estadísticas de clasificación de los tickets para un revisor en la primera fase. 

En la tabla se puede visualizar el número de tickets que componen cada uno de los tres grupos de clasificación, 'Es un error, 'No es un error' y  'Unknown', así como el porcentaje en '\%' que se ha obtenido en cada grupo. 

Además, disponemos de la posibilidad de dibujar un gáfico de barras en el que se muestre visualmente el porcentaje de tickets para cada grupo. Como se puede observar en la imágen ~\ref{figura:Statistics}.

Para conseguir esto, lo único que debe hacer el usuario es pulsar sobre el botón  \textit{'Draw'}. A la derecha del gáfico disponemos de un menú desplegable que nos permite descargar la imagen, mostrada en gáfico de barras, con diferentes extensiones.

\begin{figure}
    \centering
    \includegraphics[scale=0.38]{img/Statistics}
    \caption{Visualización de la Web tras pulsar la pestaña 'Analyze'}
    \label{figura:Statistics}
\end{figure}


\subsection{Modify}
\label{subsec:modify}

Tras pulsar sobre la última pestaña  \textit{'Modify'}, se nos proporciona en la parte izquierda un listado con todos los tickets que han sido analizados y se encuentran guardados en el repositorio GIT asociado a la apliación,  en la parte derecha aparece un formulario vacío, el cual se autocompletará tras clicar sobre un ticket. 

Esta funcionalidad está diseñada con el fin de proporcionar al desarrollador un lugar en el que pueda modificar aquellos tickets que ya han sido analizados y guardados previamente. Ya sea porque cometió un fallo,  porque quiere añadir mas información o simplemente porque ha cambiado de opinión tras volverlo a revisar.

En el formulario todos los campos que se rellenan pueden ser modificados a excepción del nombre del desarrollador, ya que para los resultados necesitamos saber quien ha sido el desarrollador y no nos parece apropiado que se pueda cambiar el nombre del desarrollador. Podría suceder que el propio desarrollador se equivocase al introducir su nombre, en ese caso, habría que eliminar el ticket desde el repositorio de Github.

El aspecto que posee la web tras haber pinchado en la pestaña  \textit{'Modify'} aparece en la figura \ref{figura:Modify}

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{img/Modify}
    \caption{Visualización la Web tras pulsar la pestaña 'Modify'}
    \label{figura:Modify}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados }
\label{sec:resultados}
Este capítulo se divide en dos secciones. La primera de ellas referente a los resultados obtenidos durante el estudio, en sus dos fases del experimento. Y la segunda sección se centra en detallar los resultados generales del trabajo fin de máster.

\section{Resultados del estudio}
\label{sec:resultadoest}
A continuación se exponen los resultados obtenidos tanto en la primera fase de nuestro experimento, como en la segunda fase. En ambos casos, se muestran las gráficas y tablas resultantes tras analizar los datos obtenidos.

\subsection{Resultados primera fase}
\label{sec:resultadosF1}
Los resultados obtenidos en la primera fase del experimento, hacen referencia a la primera clasificación, agrupando los tickets en  'Es un error', 'No es un error' y ' No podemos saberlo'. 

\begin{table}[htb]
\centering
\begin{tabular}{|l |c|}
\hline
\multicolumn{2}{|c|}{Classification First Stage} \\ \hline
Groups & Tickets belonging to (\%) \\
\hline \hline
It is an error & 63 \\ \hline
It is not an error & 21 \\ \hline
Unknown & 16 \\ \hline
\end{tabular}
\caption{Clasificación de los tickets dentro de cada grupo }
\label{tabla:firstStage}
\end{table}

La primera tabla obtenida, cuadro ~\ref{tabla:firstStage}, representa el porcentaje de tickets para cada una de las tres clasificaciones. Podemos ver que de los 100 tickets analizados más de 50\% son clasificados como tickets que notifican un verdadero error, mientras que un 21\% de los tickets describían situaciones que no han sido consideradas como error debido a que eran actualizaciones requeridas, nuevas funcionalidades u otros casos. En esta tabla se observa también como un 16\% de los tickets no han podido ser clasificados con la etiqueta error ó no error, es un porcentaje relativamente pequeño como para que pueda influir en gran medida en los resultados de la segunda fase. A pesar de ello, en este momento se asumirá que estamos cometiendo un pequeñ error en los datos de la siguiente fase debido a este 16\%.

La segunda tabla obtenida, cuadro ~\ref{tabla:firstStageImportance}, muestra el porcentaje de los tickets agrupados en una categoría, dependiendo de la importancia que se les dió en Launchpad a lo largo de su vida.  En la figura ~\ref{fig:degree} podemos ver dichos datos en un gráfico de barras.
\begin{table}[htb]
\centering
\begin{tabular}[t]{|l |c |c |c |r|}
\hline
\multicolumn{5}{|c|}{Classification depend of the importance} \\ \hline
Importance & It is an error & it is not an error & Unknown & Total \\
\hline\hline
Critical & 4 & 1 & 1 & 6\\
\hline 
High & 25 & 3 & 7 & 35\\
\hline
Medium & 16 & 3 & 4 & 23\\
\hline
Low & 8 & 6 & 3 & 17\\
\hline
Undecided & 10 & 8 & 1 & 19\\ 
\hline
Total & 63 & 21 & 16 & 100 \\ \hline
\end{tabular}
\caption{Clasificación de los tickets dependiendo la importancia de éstos en Launchpad  }
\label{tabla:firstStageImportance}
\end{table}

\begin{figure}[htb]
	\centering
	\includegraphics[width=1.1\textwidth]{img/firstStage} 
	\caption{Resultados de la primera fase} \label{fig:degree}
\end{figure}

La conclusión que podemos extraer de esta tabla, asumiendo que la comunidad de Launchpad usa con criterio las etiquetas de importancia en sus tickets, son las siguientes:
\begin{enumerate}
    \item Un ticket cuya etiqueta de importancia sea  \textit{Critical} tiene un 66,66\% de posibilidades de ser un error.
    \item Un ticket cuya etiqueta de importancia sea  \textit{High} tiene un 71,42\% de posibilidades de ser un error.  \item Un ticket cuya etiqueta de importancia sea 'Medium' tiene un 69,56\% de posibilidades de ser un error.  
    \item Un ticket cuya etiqueta de importancia sea  \textit{Low} tiene un 47,05\% de posibilidades de ser un error.
    \item Un ticket cuya etiqueta de importancia sea  \textit{Undecided} tiene un 52,63\% de posibilidades de ser un error.    
   \end{enumerate}

Por lo tanto, el factor de importancia de un ticket, podría ser considerado como ayuda para los desarrolladores a la hora de decidir si un ticket es error o no lo es. Además, este factor puede utilizarse conjuntamente con la presencia de ciertas palabras o keywords para proporcionar unos mejores resultados.
  
\subsection{Resultados segunda fase}
\label{sec:resultadosF2}
En esta sección hablaremos sobre los datos obtenidos en la segunda fase de clasificación, donde los resultados indican la responsabilidad que ejercen los commits inmediatamente anteriores en el error introducido en el código fuente.

La primera tabla obtenida, cuadro ~\ref{tabla:secondStage}, muestra el porcentaje de commits previos en cada una de las tres categorías. En ella observamos como en el 33,08\% de los commits previos que han sido analizados y que han formado parte de la insercción de un error en el código, no son responsables.
\begin{table}[htb]
\centering
\begin{tabular}{|l |c|}
\hline
\multicolumn{2}{|c|}{Classification Second Stage} \\ \hline
Responsibility & Number of commits (\%) \\
\hline \hline
It is responsible & 49,62 \\ \hline
It is not responsible & 33,08 \\ \hline
Unknown & 17,29 \\ \hline
\end{tabular}
\caption{Clasificación de la responsabilidad del commit anterior }
\label{tabla:secondStage}
\end{table}

Acabamos de demostrar con datos obtenidos en nuestro experimento empírico, que la actual premisa establecida en la literatura acerca de que el responsable de añadir un error en el código es el commit previo sólo se cumple en un 49,62\% de los casos. Este dato no puede ser considerado como muy fiable puesto que hemos analizado una población pequeña de tickets, concretamente 100, de los que solamente 63 han pasado la fase de filtrado. A pesar de no poder asegurar que estos porcentajes se cumplan al analizar una población mayor de tickets, si podemos asegurar que hay una leve tendencia que nos indica a pensar que no todos los commits previos son responsables.

Es más, si dividimos aquellos tickets en los que sólo ha habido un commit previo implicado, de aquellos en los que ha habido más de un commit implicado, los resultados son, cuanto menos, curiosos. A continuación se muestran los porcentajes de los commits anteriores en cada una de las tres categoías, tanto para el caso de que sólo tengamos un commit antecesor, cuadro ~\ref{tabla:secondStageOne}, como para el caso de los que tienen más de un commit, cuadro ~\ref{tabla:secondStageMore}.
\begin{table}[htb]
\centering
\begin{tabular}{|l |c|}
\hline
\multicolumn{2}{|c|}{Responsibility when only it is a commit} \\ \hline
Responsibility & Number of tickets (\%) \\
\hline \hline
It is responsible & 75,86, \\ \hline
It is not responsible & 6,90 \\ \hline
Unknown & 12,24 \\ \hline
\end{tabular}
\caption{Clasificación de la responsabilidad del commit anterior}
\label{tabla:secondStageOne}
\end{table}

De los 63 tickets que pasaron a la segunda fase, 29 de ellos solamente tenían un commit previo involucrado, mientras que 25 de los tickets tenían más de un commit. A los 9 tickets restantes no se encontró ningón commit previo puesto que los errores se habían solucionado en el repositorio de otro de los componentes de OpenStack distinto a Cinder.

Ahora bien, en la tabla ~\ref{tabla:secondStageOne} situada encima de este párrafo y perteneciente a los tickets con sólo un commit, podemos observar como en el 75,86\% de ellos, el commit previo fue el responsable de introducir el error. Mientras que solamente el 6,90\% de los commits no fuero responsables del error. 
En este caso, podemos pensar que nuestra hipótesis no es significativa y se podría seguir con la premisa actual de que el commit previo es el responsable del error, en cierto caso algo lógico puesto que solamente un commit previo se ve implicado.  

Lo interesante aparece cuando observamos la tabla, cuadro \ref{tabla:secondStageMore} con los resultados de los tickets donde se ven implicados más de un commit previo. Ahí podemos comprobar como nuestra hipótesis vuelve a recobrar fuerza, ya que el porcentaje de commits previos responsables y el porcentaje de commits previos no responsables se puede considerar idénticos, puesto que en un 46\% de los casos el commit previo es responsable mientras que en un 44\% de los casos el commit previo no es responsable.
 
\begin{table}[htb]
\centering
\begin{tabular}{|l |c|}
\hline
\multicolumn{2}{|c|}{Responsibility when there are more than one commit} \\ \hline
Responsibility & Number of tickets (\%) \\
\hline \hline
It is responsible & 46,32 \\ \hline
It is not responsible & 44,21 \\ \hline
Unknown & 9,47 \\ \hline
\end{tabular}
\caption{Clasificación de la responsabilidad del commit anterior}
\label{tabla:secondStageMore}
\end{table}

En las gráficas inferiores se muestra unos gráficos de barras obtenidos con los datos de las tablas ~\ref{tabla:secondStageOne} y ~\ref{tabla:secondStageMore} .
\begin{figure}[htb]
	\centering
	\includegraphics[width=1.1\textwidth]{img/secondStage} 
	\caption{Resultados de la segunda fase} \label{fig:degree3}
\end{figure}

Con todos los datos analizados, podemos realizar multitud de tablas que nos ayudan de una forma u otra a obtener diversas tablas como la mostrada en el cuadro ~\ref{tabla:firstStageTypeMoreOne} , en ella podemos visualizar el grado de responsabilidad que ejercen todos los commits previos en un ticket. Dicha tabla separa los tickets en los cuales hay dos, tres, cuatro y más de cinco commits implicados, obteniendo los siguientes resultados:
\begin{enumerate}
    \item Un ticket en el cual se vean implicados dos commits, en un 57  \% de los casos la responsabilidad se reparte, mientras que en un 43 \% de los casos los dos commits son responsables del error.
    \item Un ticket en el cual se vean implicados tres commits, en el 100  \% de los casos la responsabilidad del error supera el 50 \% , por tanto dos de los tres tickets son responsables.
    \item Un ticket en el cual se vean implicados cuatro commits, en un 33  \% de los casos la responsabilidad es menor al 50 \%, mientras que en un 66 \% de los casos la responsabilidad supera el 50 \%.
    \item Un ticket en el cual se vean implicados más de cinco commits, en un 83  \% de los casos la responsabilidad del error es menor del 50 \%.     
   \end{enumerate}
 Con esto, podemos decir que podría haber una tendencia marcada, en la cual, aquellos tickets que tengan más de cinco commits previos, la mayor parte de ellos no son responsables de haber introducido el error. Mientras que para tickets con 3 y 4 commits previos, la responsabilidad que ejercen la mayor parte de los commits previos es elevada.
 
\begin{table}[hr]
\centering
\begin{tabular}[t]{|l |c |c |r|}
\hline
\multicolumn{4}{|c|}{Grade of total responsability of each commit inside a ticket} \\ \hline
Number of commits & less than 50 \% & responsibility = 50 \% & more than 50 \% \\
\hline\hline
2 & 0 & 57,14 & 43,86\\
\hline
3 & 0 & 0 & 100\\
\hline
4 & 33,33 & 0 & 66,66\\
\hline
+5 & 83,33 & 3 & 16,66\\ \hline
\end{tabular}
\caption{Grado de responsabilidad de cada commit dentro de un ticket}
\label{tabla:firstStageTypeMoreOne}
\end{table}

En las gráficas inferiores se muestra unos gráficos de barras obtenidos con los datos de las tablas ~\ref{tabla:firstStageTypeMoreOne} 
\begin{figure}[htb]
	\centering
	\includegraphics[width=1.1\textwidth]{img/responsability} 
	\caption{Grado de responsabilidad de cada uno de los commits en un ticket} \label{fig:responsability}
\end{figure}


\section{Resultados generales}
\label{sec:resultadosGenerales}

%Ahora es el momento de evaluar todos los resultados obtenidos en las dos secciones previas, y decidir cual será el futuro de nuestro trabajo de investigación.
%
%Los resultados obtenidos en la primera fase, no nos aportan demasiado en nuestro estudio de investigación, no obstante, son resultados bastante apropiados para tenerlos en cuenta en versiones futuras de nuestra herramienta. De tal manera que la herramienta facilite dichos resultados para que sirvan de apoyo a los desarrolladores en el momento de tomar realizar la primera fase. Creemos que de esta manera el número de tickets agrupados bajo la etiqueta de 'No sabemos clasificarlo' se reduzca, reduciendo así el error cometido en la clasificación final.
%
%En realidad, los resultados que nos interesaban son los obtenidos en la segunda fase. en esta fase hemos podido corroborar empíricamente que la asunción actual acerca de que el commit previo es el responsable del error no se cumple para todos los casos, y por tanto nuestra investigación puede seguir su rumbo. A pesar de haber analizado una población de tickets pequeña, tenemos la certeza que el no analizar la responsabilidad de los tickets previos provoca un error en los resultados, por tanto, si seguimos en este área investigando y llegando a resultados más fiables podremos aportar un nuevo punto de vista al Bug seeding.  

Tras la realización de este proyecto se han obtenido dos items, el primero de ellos se trata del estudio empírico realizado, del que tenemos resultados favorables para continuar investigando en este área. El segundo item, se trata de la herramienta desarrollada que servirá de ayuda en los consiguientes análisis.

La duración del proyecto ha sido aproximadamente un año, los primeros seis meses estuvieron dedicados a entender el problema, realizando pruebas y análisis iniciales con el fin de acabar encontrando una metodología adecuada. Los siguientes dos meses, estuvieron dedicados a analizar los 100 tickets extraídos del proyecto Cinder, en la fase de análisis conté con la ayuda de mi compañera Andrea Villaverde, debatiendo opiniones y comprobando que la metodología descrita era la adecuada.
La herramienta fue desarrollada y validada durante los ultimo cuatro meses, añadiendo cada vez mas funcionalidades, hasta cumplir con los objetivos. Obteniendo una herramienta que posee aproximadamente de 1000 líneas de código desarrollado accesibles en \footnote{\url{https://github.com/Gemarodri/BugTracking}}. La herramienta se encuentra disponible en \url{http://bugtracking.libresoft.es}, por tanto cualquier persona que quiera probarla puede hacerlo.

En \url{http://gemarodri.github.io/Presentacion/} podemos encontrar una web que reúne todos los recursos disponibles en el TFM, como son la memoria, la herramienta desarrollada y su código fuente. Además hemos añadido una demo en la que se presenta el funcionamiento de la herramienta. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}
Con este capítulo llegamos al final de nuestra memoria, describiremos en él si los objetivos marcados en los primeros capitulos se han cumplido o no. Hablaremos además, sobre los conocimientos aplicados y las lecciones aprendidas en el transcurso de este proyecto, así como de las líneas de trabajo futuro. Finalizando dicho capítulo con una valoración personal.
 
\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Hemos sido capaces de situar al lector en un plano en el que pueda entender la literatura actual sobre el área de conocimiento que engloba el bug- seeding, comprendiendo la necesidad de investigar la importancia que el commit previo ejerce en la responsabilidad de un error. Entendiendo el proceso necesario para rastrear un error, por tanto hemos cumplido con el \textit{Objetivo 1}.

En el capitulo \ref{sec:estudiodone} se ha detallado todos los pasos de los que consta nuestra metodología, de tal manera que cualquiera pueda realizar el mismo experimento, cumpliendo así el \textit{Objetivo 2}.

Hemos aportado datos y gráficas fiables en las secciones \ref{sec:fase1} y \ref{sec:fase2}. Por tanto los \textit{Objetivo 3, 4, y 5} quedan realizados. Dichos datos incitan a seguir investigando, dándole un mayor alcance a la investigación, puesto que creemos que los resultados son favorables a nuestro planteamiento. 

El \textit{Objetivo 6} no hemos sido capaces de realizarlo completamente, ya que solo se ha automatizado la primera fase del estudio en la herramienta. Esto se debe a que la segunda fase todavía recomendamos hacerla manualmente, debemos tener muchos factores en cuenta al analizar código y probablemente, cuanto más código analicemos más situaciones diferentes podemos encontrarnos, para tenerlas todas ellas en consideración.

Creemos que la herramienta cumple con el \textit{Objetivo 7} , y que su uso pueda servir de ayuda en estudios posteriores. Además la herramienta posee un carácter genérico, por tanto no solo sirve para el estudio de Cinder, si no que se puede usar para analizar cualquier otro componente de OpenStack, como indica el \textit{Objetivo 8}.

El estudio sirve como método de validación para la herramienta, y después de usar la herramienta podemos decir que el \textit{Objetivo 9} se ha cumplido, ya que ahorramos tiempo en el análisis de la primera fase. 

\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Muchos han sido los conocimientos adquiridos en estos dos años de Máster, gracias a ellos, el trabajo descrito en la presente memoria ha sido más fácil. Asignaturas como DAT  \textit{Desarrollo de Aplicaciones Telemáticas}, ISRH  \textit{Integración de Servicios y Redes Heterogéneas}, ISI  \textit{Ingenieria de Sistemas de Información} ó GORS  \textit{Gestión y OperacióN de Redes y Servicios}, han aportado las tablas para poder manejarme, con relativa soltura, a la hora de programar ó para resolver problemas. 

Los conocimientos y habilidades previamente adquiridos durante los cursos, de los cuales he hecho uso durante este trabajo fin de máster, son los siguientes: 

\begin{enumerate}
  \item Se han aplicado los conocimientos sobre las tecnologías que engloban HTML5, así como el lenguaje JavaScript y el entorno NodeJS, adquiridos en las asignaturas anteriormente nombradas. 
  \item Una de las grandes habilidades que me ha aportado el TFM, es el aumento de la capacidad autodidacta que todo trabajo de investigación requiere. Durante el máster, muchas de las asignaturas requerían cierto trabajo de investigación por parte del alumno. Los profesores aportaban ideas y conocimientos para que fuese el propio alumno quien llegase a una solución válida, potenciando de esta manera el aumento de la capacidad autodidacta.
 \item Por último, se han aplicado los conocimientos en la integración de diferentes tecnologías para lograr crear un Mushup, que integra varias herramientas en una sola. Asignaturas como DAT e ISRH ayudaron en que la herramienta se desarrollase con mayor velocidad.
\end{enumerate}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Durante el desarrollo del TFM, muchos han sido los conocimientos adquiridos, ya que dicho TFM empieza con el estudio y entendimiento de un nuevo campo de conocimiento llamado bug-seeding, donde encontramos unas motivaciones que nos llevaron a realizar un estudio empírico. Y fue durante el desarrollo del estudio cuando encontramos la necesidad de crear una herramienta que nos proporcionase ayuda en nuestro análisis. 

Por tanto, puedo enumerar cuales han sido los conocimientos y/o habilidades adquiridos:
\begin{enumerate}
   \item Profundizar los conocimientos sobre el  \textit{FLOSS}. 
   \item Comprensión del estado actual en el que se encuentra el campo de conocimiento tratado en este TFM, el Bug Seeding.
   \item Aprendizaje de la metodología de trabajo que posee un gran proyecto como es OpenStack, entendiendo el uso de herramientas como Launchpad y Gerrit en dicho proyecto.
   \item Creación de una APIRestFul necesaria en nuestra herramienta.
   \item Montar un servidor node en una maquina virtual que albergue nuestra herramienta. 
   \item Describir una metodología detallada y precisa, de tal manera que pueda ser automatizada, facilitando el estudio a los desarrolladores.
   \item Adentrarme en el entendimiento del lenguaje, desconocido para mi, Python.
\end{enumerate}

Las lecciones que puedo sacar tras todo el trabajo realizado en el TFM son:
\begin{enumerate}
\item En los primeros meses de la investigación, el deseo de obtener los primeros resultados con la mayor rapidez posible, provocó una pérdida tiempo analizando tickets sin llegar a entender en profundidad cual era el objetivo final. Teniendo que repetir, en varias ocasiones, el análisis. Por tanto, entendí que es más importante dedicar el tiempo necesario a entender los objetivos y el problema que se plantea antes de conseguir resultados rápidos.
\item Analizar cual son las necesidades que tenemos y como la tecnología nos facilita el trabajo.
\item Comprender el estado del arte actual para entender como ayuda nuestra investigación en él.
\end{enumerate}

\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Hay dos lineas de trabajo futuro, una relacionada con el trabajo de investigación y la otra relacionada con la herramienta que hemos desarrollado. A pesar de que ambas líneas deberán ser complementarías, podemos permitir que la línea de investigación siga su curso, llevando a cabo experimentos con nuevas ideas que han surgido gracias a la realización de este primer estudio. Mientras que la herramienta puede seguir evolucionando y mejorando, aportando más funcionalidades, siempre y cuando siga cumpliendo las necesidades que el estudio de investigación requiera. 

Por todo ello, los trabajos futuros en la investigación son:
\begin{itemize}
	\item Extender la investigación a otros componentes de OpenStack.
	\item Experimentar con los datos obtenidos y el machine learning en busca de características claves que nos ayuden a tomar la clasificar los tickets con la mayor precisión posible.
	\item Obtener información más detallada sobre los commits y los ficheros involucrados, ya que podríamos obtener nuevas relaciones que nos ayuden en un futuro para predecir si el commit es el causante o no. Actualmente, no hemos realizado la extracción de dichas características en nuestro estudio.
	\item Añadir nuevos campos para analizar, como son la hora, el día de la semana ó incluso en nombre del responsable de introducir el commit para encontrar alguna relación en el momento de introducir el error en el código.  
\end{itemize}

Si nos centramos en la herramienta, los posibles trabajos futuros se centran en:
\begin{itemize}
	\item Automatizar la segunda fase, incluyéndola en la herramienta.
	\item Proporcionar una mayor interactividad con el usuario cubriendo sus necesidades, para ello sería imprescindible que un grupo de desarrolladores probasen nuestra herramienta y nos aportasen sugerencias ó mejoras.
	\item Añadir la representación de gráficas y tablas de clasificación que actualmente no se encuentran disponibles como son aquellas obtenidas en la segunda fase del experimento.
	\item Brindar al desarrollador sugerencias de clasificación basadas en las keywords y otras posibles características que puedan ayudar. Para ello previamente hemos tenido que usar machine learning.
	\item Estandarizar todo lo posible la herramienta para que pueda usarse con cualquier proyecto que use Launchpad y Gerrit.
	\item Optimizar al máximo el código, ya que no sabemos como puede afectarle el trabajar con una gran cantidad de datos.
\end{itemize}

\section{Valoración personal}
\label{sec:valoracion}
Hallar un nuevo area de conocimiento, antes desconocida para mi, en la cual hay muchas posibilidades de investigación, me ha aportado esa curiosidad de querer seguir investigando, aportando nuevas ideas y aprendiendo cada día un poco más sobre este tema. 
 
El esfuerzo ejercido durante la investigación y las fases de análisis se ve recompensado al llegar a obtener datos que avalan una teoría inicial. Además poder crear una herramienta que permita ahorrar tiempo de análisis, en la cual puedas añadir funcionalidades dependiendo de tus necesidades, es realmente gratificante.

Poder hacer uso de las tecnologías más activas actualmente como son HTML5 y Bootstrap y afianzar de la misma manera los conocimientos sobre JavaScript y Jquery, me ha aportado una mayor seguridad para afrontar futuros retos en los cuales se requiera el uso de estas tecnologías.

Por todo ello, me gustaría concluir diciendo que la valoración personal ha sido realmente positiva, he aprendido muchas cosas las cuales podré aplicar en el futuro, tanto a nivel personal como a nivel profesional, y me siento en el deber de dar las gracias al grupo de LibreSoft, ya que son ellos los que me han ayudado en todo momento para en el TFM.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\thispagestyle{empty} 
\chapter{Artículo realizado}
\label{app:articlel}
En la memoria se adjunta el artículo que hemos escrito, donde se describe detalladamente la investigación llevada a cabo. El artículo plantea y da respuesta a ciertas preguntas de investigación, y detalla el proceso seguido para extraer los datos de los que hemos obtenidos distintas gráficas y conclusiones

\thispagestyle{empty} 
\includepdf[pages={1-9}]{Bug_Insertion.pdf}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\nocite{*}
\nocite{HTML5:Misc}
\nocite{JavaScript:Misc}
\nocite{JQuery:Misc}
\nocite{CSS3:Misc}
\nocite{Git:Misc}
\nocite{Github:Misc}
\nocite{Bootstrap:Misc}
\nocite{Launchpad:Misc}
\nocite{Gerrit:Misc}
\nocite{Node:Misc}
\bibliographystyle{alpha}
\bibliography{memoria}
  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}

